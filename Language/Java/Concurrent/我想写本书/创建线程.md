# 创建线程

方法一：实现Runnable接口，重写run()函数，运行start()方法
方法二：继承Thread类，重写run()函数，运行start()方法

Runnable接口代码，抽象函数接口

```java
@FunctionalInterface
public interface Runnable {
    /**
     * When an object implementing interface <code>Runnable</code> is used
     * to create a thread, starting the thread causes the object's
     * <code>run</code> method to be called in that separately executing
     * thread.
     * <p>
     * The general contract of the method <code>run</code> is that it may
     * take any action whatsoever.
     *
     * @see     java.lang.Thread#run()
     */
    public abstract void run();
}
```

Thread类代码：

start方法

```java
public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)//调用两次start报错原因
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }

```

run方法：

```java
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```

Thread是线程，Runnable是线程执行体

创建线程的方式根本上只有一种：Thread.start()

但是绑定Thread类target（持有Runnable对象）的方式有多种花样：
Lumbda
重写Thread的run方法
通过Thread构造器传入Runnable对象

经典错误观点:
“线程池创建线程也算是一种新建线程的方式”

![](_v_images/20191016095234286_1492777927.png)

ThreadPoolExecutor

```java
public class ThreadPool {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 1000; i++) {
            executorService.submit(new Task() {});
        }
    }
}

class Task implements Runnable {

    @Override
    public void run() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
}
```

```java
@NotNull public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```
newCachedThreadPool()只是收集参数，具体实现在submit native方法中
<font color="red">Future<?> submit(Runnable task);应该看看源码</font>


“通过Callable和FutureTask创建线程，也算是一种新建线程的方式”
“无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”
定时器:private final TimerThread thread = new TimerThread(queue);
匿名内部类：重写run方法
lambda表达式：定义Runnable不同方式


---

需要更加细致了解的：
线程池源码中submit
Timmer源码
Thread中start