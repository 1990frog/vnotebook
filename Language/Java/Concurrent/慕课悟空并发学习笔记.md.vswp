vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/Language/Java/Concurrent/慕课悟空并发学习笔记.md
# 前言

## 并发重要性

并发是众多框架的原理和基础

## 在日常开发中并发的使用

1. Spring中对线程池、单例的应用
2. 数据库中乐观锁思想
3. Log4j2对阻塞队列的应用

## 面试技巧

从一个点引申出并发知识架构，展现知识储备和深刻理解，为面试加分

## 科学有效的学习

1. 如何从宏观和微观两个方面提高技术，有哪些途径？
2. 如何了解技术领域的前沿动态？
3. 如何在业务缠身中得到更多成长？
4. 如何分析Java中native层的c/cpp代码？
5. 为何自顶向下学习？

---

# 线程启停

## 启动线程

### start

start流程：

1. 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中或者已结束的线程，都不能再次启动，代码演示详见CantStartTwice类）
2. 被加入线程组
3. 调用start()方法启动线程

注意点：

1. start方法是被synchronized修饰的方法，可以确保线程安全；
2. 由JVM创建的main方法线程和system组线程，并不会通过start来启动。

### native方法

native方法（由c或cpp编写），如果想看源码，去网站看openjdk实际实现

#### 如何分析native方法

进入github（也可以进入 openJDK网站 ）
点“搜索文件”，搜索对应的c代码类Thread.c
找到native方法对应的方法名
去src/hotspot/share/prims/jvm.cpp里看cpp代码

![](_v_images/20190905205555461_716593482.png)

## 停止线程

### 原理介绍：

使用interrupt来通知，而不是强制停止线程（强制中断的线程，都是过期方法了，官方不推荐使用）

1. 原理：用interrupt来请求、好处
2. 想停止线程，要请求方、被停止方、子方法被调用方相互配合
3. 最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况

如何处理不可中断的阻塞

并不是所有的阻塞都是可中断的, 比如InputStream.read方法. 在检测到输入数据可用, 到达流末尾或者抛出异常前, 该方法一直阻塞. 而且阻塞的时候不会检查中断标记, 所以中断线程无法使read从阻塞状态返回. 但是关闭流可以使得read方法抛出异常, 从而从阻塞状态返回。  

1. 并没有通用的方法，针对特定的情况，使用特定的方法
2. 使用可以响应中断的方法

### Java中停止线程的原则是什么？

在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。

任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。然而,有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是运行超时或出错了。

要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断(Interruption),这是一种协作机制,能够使一个线程终止另一个线程的当前工作。

这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止,因为这种立即停止会使共享的数据结构处于不一致的状态。相反,在编写任务和服务时可以使用一种协作的方式:当需要停止时,它们首先会清除当前正在执行的工作,然后再结束。这提供了更好的灵活性,因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。

生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运的软件之间的最主要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。

### 中断sleep

#### 实际开发中的两种最佳实践：

1. 优先选择：传递中断（万金油）
2. 不想或无法传递：恢复中断（上一种不能用的情况下使用，不应屏蔽中断）

#### 传递中断：

添加异常到方法签名，在方法上抛出异常。用throws InterruptedException 标记你的方法，不采用try 语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，由于run方法内无法抛出checked Exception（只能用try catch），顶层方法必须处理该异常，避免了漏掉或者被吞掉的情况，增强了代码的健壮性。

<font color="red">e.printStackTrace();能传递异常吗？</font>

例如：
```java
void subTask() throws InterruptedException
    sleep(delay);
}
```

#### 恢复中断

##### 如果不能抛出中断，要怎么做

如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法throws InterruptedException），那么应该选择在catch 子句中调用**Thread.currentThread().interrupt()** 来恢复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。  
代码演示详见视频，在这里，线程在sleep期间被中断，并且由catch捕获到该中断，并重新设置了中断状态，以便于可以在下一个循环的时候检测到中断状态，正常退出。  

##### 响应中断的方法总结列表

1. Object.wait()/wait(long)/wait(long,int)
2. Thread.sleep(long)/sleep(long,int)
3. Thread.join()/join(long)/join(long,int)
4. java.util.concurrent.BlockingQueue.take()/put(E)
5. java.util.concurrent.locks.Lock.lockInterruptibly()
6. java.util.concurrent.CountDownLatch.await()
7. java.util.concurrent.CyclicBarrier.await()
8. java.util.concurrent.Exchanger.exchange(V)
9. java.nio.channels.InterruptibleChannel相关方法
10. java.nio.channels.Selector的相关方法

##### 为什么要用interrupt来停止线程：

被中断的线程它本身拥有响应中断的权利，因为有些线程的某些代码是非常重要的，我们必须要等待这些线程处理完成之后或者他们准备好之后，再由他们自己去主动终止，或者它们真的不想理会我们的中断这也是完全ok的，我们不应该茹莽的使用stop方法，而是通过使用interrupt方法来发出一个信号，由它们自己处理，这样使我们的线程代码，在实际中更加安全，也完成了清理工作，数据的完整性也得到了保障

### 错误停止方法：

1. 被弃用的stop,suspend和resume方法
2. 用volatile设置boolean标记位

### 停止线程相关重要函数解析

判断是否已被中断相关方法  

```java
static boolean interrupted()
//返回中断状态，并清除中断状态
return isInterrupted(true);
```

作用对象是当前运行它的线程，执行线程，该方法不关心被哪个对象调用，只关心执行它的线程


```java
boolean isInterrupted()

//返回中断状态
return isInterrupted(false);
```

Thread.interrupted()的目的对象  
Thread可看做this  

### Thread


---

# JAVA异常体系

![](_v_images/20190903225518559_2071670296.png)


## 非受检查异常：

### Error:  

VirtualMachineError
AWTError

### Exception:

RuntimeException

## 受检查异常：

IOException

---

# 线程的6种状态

## 6种状态

1. New：已创建，但没启动，未执行Run方法
2. Runnable：调用了start方法，未分配资源也是此状态，Runnable可运行的，也可能是已运行中的
3. Blocked：进入synchronize修饰的代码块，仅synchronize
4. Waiting：
5. Timed Waiting
6. Terminated

## 阻塞状态

一般习惯而言，把Blocked（被阻塞）、Waiting（等待）、Timed_waiting（计时等待）都称为阻塞状态，不仅仅是Blocked

![](_v_images/20190907171200301_1137895628.png)


---

1.为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？

2.多种方式实现生产者模式

3.Join和sleep和wait期间线程的状态分别是什么？为什么？ 

|        |                               |                                                                                                                     |     
| ------ | ----------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| 类     | 方法名                        | 简介                                                                                                                |
| Thread | sleep相关                     | 本表格的“相关”，指的是重载方法，也就是方法名相同，但是参数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异 |
|        | join                          | 等待其他线程执行完毕                                                                                                |
|        | yield相关                     | 放弃已获取到的cpu资源                                                                                               |
|        | currentThread                 | 获取当前执行线程的引用                                                                                              |
|        | start,run相关                 | 启动线程相关                                                                                                        |
|        | interrupt相关                 | 中断线程                                                                                                            |
|        | stop(),suspend(),resume()相关 | 已废弃                                                                                                              |
| Object | wait/notify/notifyAll相关     | 让线程暂时休息和唤醒                                                                                                |

---

阻塞阶段
直到以下4种情况之一发生时，才会被唤醒
1.另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程；
2.另一个线程调用这个对象的notifyAll()方法；
3.过了wait(long timeout)规定的超时时间，如果传入0就是永久等待；
4.线程自身调用了interrupt()

唤醒阶段
notify唤醒一个（操作系统调度）
notifyAll唤醒全部

遇到中断

---

wait,notify,notifyAll特点、性质
1.用必须先拥有monitor
2.只能唤醒一个
3.属于Object类
4.类似功能的Condition
5.同时持有多个锁的情况

---

多种方式实现生产者消费者模式

为什么wait()需要在同步代码块内使用，而sleep()不需要？
主要是让通信变得可靠，防止死锁或者永久等待的发生，如果我们不把wait，notify都放在代码块里面，那么很有可能在它执行位置之前，线程突然切换到一个执行notify的线程 ，这样一来，对面的第二个线程，就把所有的notify代码都执行完毕了之后又切过来执行wait，没有synchronize保护，就可以在执行wait之前突然切换过去，这样会导致执行wait的线程永远不会被唤醒。 
而sleep是针对自己单独线程的，和其他线程关系不大

为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？
在java中wait，notify，notifyAll是锁级别的操作，而锁是属于每一个对象的，锁是绑定到每一个对象中，而不是线程中 ，同样的道理，我们反过来想，如果将w/n/n定义到Thread中，就会造成很大的局限性，经常我们会操作多把锁，如果定义在Thread中，就无法去实现这样灵活的逻辑了。

wait方法是属于Object对象的，那调用Thread.wait会怎么样？
Thread类非常特殊，在线程退出的时候会自动的调用notify，这样会使我们设计的流程受到干扰。

如何选择用notify还是notifyAll？

notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？
如果没有抢到，就会等待再次释放锁，或接受线程调度器的调度。

为什么弃用suspend()和resume()来阻塞线程？

---

sleep方法：
作用：我只想让线程在预期的时间执行，其他时候不要占用CPU资源，一旦调用sleep线程就会进入阻塞状态，就不会占用cpu资源。直到它下次被调度起来之后
特点：
不释放锁（包括synchronize和lock）
和wait不同，始终持有锁，而wait会释放锁

sleep方法响应中断
1.抛出InterruptedException
2.清除中断状态

sleep第二种写法（更优雅）：TimeUnit

sleep方法可以让线程进入Waiting状态，并且不占用cpu资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态

wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）
相同：
1.wait和sleep方法都可以使线程阻塞，对应线程状态是waiting或time_waiting。
2.wait和sleep方法都可以响应中断Thread.interrupt（）。
不同：
1.wait方法的执行必须在同步方法中进行，而sleep则不需要。
2.在同步方法里执行sleep方法时，不会释放monitor锁，但是wait方法会释放monitor锁。
3.sleep方法短暂休眠之后会主动退出阻塞，而没有指定时间的wait方法则需要被其他线程中断后才能退出阻塞。
4.wait()和notify()，notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法。


---

join方法作用、用法
作用：因为新的线程加入了我们，所以我们要等他执行完再出发
用法：main等待thread1执行完毕，注意谁等谁

join注意点
CountDownLatch或CyclicBarrier类

在join期间，线程处于哪种线程状态？
WAITING

---

yield方法
作用：释放我的CPU时间片，但是不会释放锁，也不会陷入阻塞
定位：JVM不保证遵循，为了保证程序的稳定性，一般开发中不使用yield，但是这个方法，并发包的类中运用的场合比较多。

yield与sleep区别：是否随时可能再次被调度

---

什么时候我们需要设置守护线程？

我们应该如何应用线程优先级来帮助程序运行？有哪些禁忌？

不同的操作系统如何处理优先级问题？

---

线程各属性

线程各属性纵览：
1.线程id：每个线程有自己的id，用于标识不同的线程
2.线程名字name：作用让用户或程序员在开发、调试或运行过程中，更容易区分每个不同的线程、定位问题等。
3.守护线程isDaemon：true代表该线程是【守护线程】，false代表线程是非守护线程，也就是【用户线程】。
4.线程优先级Priority：优先级这个属性的目的是告诉线程调度器，用户希望哪些线程相对多运行、哪些少运行。

java只有以下两种情况发生，程序才能结束：
1.调用system.exit()
2.代码执行完毕

守护线程
例子：垃圾处理器
作用：给用户线程提供服务
特性：
1.线程类型默认继承自父线程
2.被谁启动
3.不影响JVM退出

main非守护线程

守护线程和普通线程的区别：
整体无区别
唯一区别在于影响JVM退出

我们是否需要给线程设置为守护线程？
不安全，可能造成数据不一致

---

线程优先级
10个级别、默认5
MIN_PRIORITY=1
NORM_PRIORITY=5
MAX_PRIORITY=10
程序设计不应该依赖于优先级：
1.不同操作系统不一样，优先级高度依赖操作系统，java通常会把优先级映射到操作系统的优先级上。最终的调度最终依赖于操作系统。例如windows优先级有7级：windows中的1,2级对应java中的最低级，3、4对应次中级，5对应通常级别norm级别。java是一次编
 写多平台运行，在linux中优先级会被忽略，所有级别都是一样的。Solaris中有2的32次方优先级。
2.优先级会被操作系统改变，windows中有一个优先级推进器的功能，当其发现某个线程特别努力想执行的话，那么就会越过优先级的设置，优先为其分配时间，这样一来设置的优先级就不起作用了。如过一个优先级设置的过低，会发生饥饿，很长时间不会运行

---

java异常体系图
实际工作中，如何全局处理异常？为什么要全局处理？不处理行不行？

UncaughtExceptionHandler

为什么使用UncaughtE  xceptionHandler？
主线程可以轻松发现异常，而子线程却不行
子线程异常无法用传统方法捕获
不能直接捕获的后果、提高健壮性

两种解决方法：
方案一（不推荐）：手动在每个run方法里进行try catch
方案二（推荐）：利用UncaughtExceptionHandler

UncaughtExceptionHandler接口
void uncaughtException(Thread t,Throwable e)

异常处理器的调用策略

源码：
![](_v_images/20190917232013255_373651365.png)


实现：
给程序统一设置
给每个线程单独设置
给线程池设置

run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？

线程中如何处理某个未处理异常？

一共有那几种线程安全问题？

什么是多线程的上下文切换？

---

线程安全：
《Java Concurrency In Practice》的作者Brian Goetz对“线程安全”有一个比较恰当的定义：“当多个线程访问一个对象时，如歌不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。
这句话的意思是：不管业务中遇到怎样的多个线程访问某对象或某方法的情况，而在编程这个业务逻辑的时候，都不需要额外做任何额外的处理（也就是可以像单线程编程一样），程序也可以正常运行（不会因为多线程而出错），就可以称为线程安全。
相反，如果在编程的时候，需要考虑这些线程在运行时的调度和交替（例如在get()调用期间不能调用set()），或者需要进行额外的同步（比如使用synchronized关键字等），那么就是线程不安全的。

---

全都线程安全？
运行速度、设计成本、trade off
完全不用于多线程：不过度设计

什么情况下会出现线程安全问题，怎么避免？
运行结果错误：a++多线程下出现消失的请求现象
活跃性问题：死锁、活锁、饥饿
对象发布和初始化的时候的安全问题

---

![](_v_images/20190919213223447_631956148.png =829x)

原子类：cas

---

对象发布和初始化的时候的安全问题

什么是发布
什么是溢出
1.方法返回一个private对象(private的本意是不让外部访问)
2.还未完成初始化(构造函数没完全执行完毕)就把对象提供给外界,比如:
在构造函数中未初始化完毕就this赋值
隐式溢出(注册监听事件)
构造函数中运行线程

---

各种需要考虑线程安全的情况

1.访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等

2.所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：read-modify-write、check-then-act

3.不同的数据之间存在捆绑关系的时候

4.我们使用其他类的时候，如果对方没有声明自己是线程安全的

---

为什么多线程会带来性能问题

1.调度：上下文切换
（可运行的线程数量超过cpu时会发生）
什么是上下文：保存现场
缓存开销：缓存失效
何时会导致密集的上下文切换：抢锁、IO
2.协作：内存同步

线程安全：
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方3进行任何其他的协作操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的

主要两个问题：
1.数据争用：数据读写由于同时写，会造成错误数据。
2.竞争条件：及时不是同时写造成的错误数据，由于顺序原因依然会造成错误，例如在写入前就读取了。

什么情况下会出现线程安全问题，怎么避免：
1.运行结果错误（a++多线程下出现消失的请求现象，属于read-modify-write）
2.死锁等活跃性问题（包括死锁、活锁、饥饿）
3.对象发布和初始化的时候的安全问题：
什么是发布：
1.声明为public
2.return一个对象
3.把对象作为参数传递到其他类的方法中
什么是逸出：
方法返回一个private对象（private的本意是不让外部访问）
还未完成初始化（构造函数没完全执行完毕）就把对象提供给外界：
1）在构造函数中未初始化完毕就this赋值
2）隐式逸出——注册监听事件
3）构造函数中运行线程
如何解决逸出：
副本、工厂模式

总结归纳：各种需要考虑线程安全的情况
1.访问共享的变量或资源、会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等
2.所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：
1）read-modify-write操作：一个线程读取了一个共享数据，并在此基础上更新该数据。该例子在上面的index++已经展示过了。
2）check-then-act操作：一个线程读取了一个共享数据，并在此基础上决定其下一个操作：
3.不同的数据之间存在捆绑关系的时候：ip和端口号
4.我们使用其他类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题：
比如hashmap没有声明自己是并发安全的，所以我们并发调用会出错

---

性能问题有哪些体现、什么是性能问题：
1.服务响应慢、吞吐量低、资源消耗（例如内存）过高等
2.虽然不是结果错误，但依然危害巨大
3.引入多线程不能本末倒置

为什么会有性能问题：
1.调度：上下文切换
2.协作：内存同步

![](_v_images/20191015225254518_1645817715.png)

![](_v_images/20191015225426749_1970073529.png)

![](_v_images/20191015225811144_553346380.png)


---

从Java代码到CPU指令的变化过程？
我们在Java代码中，使用的控制并发的手段例如synchronized关键字，最终也是要转化为CPU指令来生效的，我们来回顾一下从Java代码到最终执行的CPU指令的流程：

最开始，我们编写的Java代码，是*.java文件
在编译（javac命令）后，从刚才的*.java文件会变出一个新的Java字节码文件（*.class）
JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
机器指令可以直接在CPU上执运行，也就是最终的程序执行
而不同的JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别；所以我们在java代码层写的各种Lock，其实最后依赖的是JVM的具体实现（不同版本会有不同实现）和CPU的指令，才能帮我们达到线程安全的效果。
由于最终效果依赖处理器，不同处理器结果不一样，这样无法保证并发安全，所以需要一个标准，让多线程运行的结果可预期，这个标准就是JMM。

---

jvm内存结构
java内存模型
java对象模型

容易混淆：三个截然不同的概念，但是很多人容易弄混

jvm内存结构，和java虚拟机的运行时区域有关。
java内存模型，和java的并发编程有关。
java对象模型，和java对象在虚拟机中的表现形式有关。

![](_v_images/20191016214509502_797851388.png)

![](_v_images/20191016214924334_360112086.png)

java对象模型
java对象自身的存储模型
jvm会给这个类创建一个instanceKlass，保存在方法区，用来在jvm层表示该java类。
当我们在java代码中，使用new创建一个对象的时候，jvm会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。

JMM是规范（Java Memory Model）
是一组规范，需要各个JVM的实现来准守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。
如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同jvm的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。
最重要的3点内容：重排序、可见性、原子性

为什么需要JMM
c语言不存在内存模型的概念，依赖处理器，不同处理器结果不一样，无法保证并发安全。
需要一个标准，让多线程运行的结果可预期

(顶层java开发者：应用层开发者)

jmm是工具类和关键字的原理
volatile、synchronized、Lock等的原理都是jmm
如果没有jmm，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的，幸好有了jmm，让我们只需要用同步工具和关键字就可以开发并发程序。

---

Java内存模型——底层原理

重排序
重排序的代码案例、什么是重排序
重排序的好处：提高处理速度
重排序的3种情况：编译器优化、cpu指令重排、内存的“重排序”

重排序分析：

```java
public class OutOfOrderExecution {

    private volatile static int x = 0, y = 0;
    private volatile static int a = 0, b = 0;

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        for (; ; ) {
            i++;
            x = 0;
            y = 0;
            a = 0;
            b = 0;

            CountDownLatch latch = new CountDownLatch(1);

            Thread one = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    a = 1;
                    x = b;
                }
            });
            Thread two = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    b = 1;
                    y = a;
                }
            });
            two.start();
            one.start();
            latch.countDown();
            one.join();
            two.join();

            String result = "第" + i + "次（" + x + "," + y + ")";
            if (x == 0 && y == 0) {
                System.out.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }
    }
}
```

这4行代码的执行顺序决定了最终x和y的结果，一共有3种情况：
1. a=1;x=b(0);b=1;y=a(1)，最终结果是x=0,y=1
2. b=1;x=a(0);a=1;y=b(1)，最终结果是x=1,y=0
3. a=1;b=1;x=b(1);y=a(1)，最终结果是x=1,y=1
4. 会出现x=0,y=0的情况：
1）y=a;a=1;x=b;b=1;

什么是重排序：在线程1内部的两行代码的实际执行顺序和代码在Java文件中的顺序不一致，代码指令并不是严格按照代码语句顺序执行的，它们的顺序被改变了，这就是重排序，这里被颠倒的是y=a和b=1这两行语句。

重排序的好处：提高处理速度
对比重排序前后的指令优化：
a=3;
b=2;
a=a+1;

Instructions
Load a
Set to 3
Store a

Load b
Set to 2
Store b

Load a
Set to 4
Store a

假设重排序之后：
a=3;
a=a+1;
b=2;

Instructions
Load a
Set to 3
Set to 4
Store a

Load b
Set to 2
Store b

重排序明显提高了性能


重排序的3种情况
编译器优化：包括JVM，JIT编译器等
CPU指令重排：就算编译器不发生重排，CPU也可能对指令进行重排
内存的“重排序”：线程A的修改线程B却看不到，引出可见性问题

---

重排序有哪3种可能性？
重排序的3种情况分别是什么？
解答：

编译器优化
编译器（包括JVM，JIT编译器等）出于优化的目的（例如当前有了数据a，那么如果把对a的操作放到一起效率会更高，避免了读取b后又返回来重新读取a的时间开销），在编译的过程中会进行一定程度的重排，导致生成的机器指令和之前的字节码的顺序不一致。
在刚才的例子中，编译器将y=a和b=1这两行语句换了顺序（也可能是线程2的两行换了顺序，同理），因为它们之间没有数据依赖关系，那就不难得到 x =0，y = 0 这种结果了。
指令重排序
CPU 的优化行为，和编译器优化很类似，是通过乱序执行的技术，来提高执行效率。所以就算编译器不发生重排，CPU 也可能对指令进行重排，所以我们开发中，一定要考虑到重排序带来的后果。
内存的“重排序”
内存系统内不存在重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在JMM里表现为主存和本地内存，由于主存和本地内存的不一致，会使得程序表现出乱序的行为。
在刚才的例子中，假设没编译器重排和指令重排，但是如果发生了内存缓存不一致，也可能导致同样的情况：线程1 修改了 a 的值，但是修改后并没有写回主存，所以线程2是看不到刚才线程1对a的修改的，所以线程2看到a还是等于0。同理，线程2对b的赋值操作也可能由于没及时写回主存，导致线程1看不到刚才线程2的修改。
