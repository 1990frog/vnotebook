vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/Language/Java/Concurrent/mooc.md
# WUKONG

## 前言

### 并发重要性

并发是众多框架的原理和基础

### 在日常开发中并发的使用

1. Spring中对线程池、单例的应用
2. 数据库中乐观锁思想
3. Log4j2对阻塞队列的应用

### 面试技巧

从一个点引申出并发知识架构，展现知识储备和深刻理解，为面试加分

### 科学有效的学习

1. 如何从宏观和微观两个方面提高技术，有哪些途径？
2. 如何了解技术领域的前沿动态？
3. 如何在业务缠身中得到更多成长？
4. 如何分析Java中native层的c/cpp代码？
5. 为何自顶向下学习？

## 启动线程

### start

start流程：

1. 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中或者已结束的线程，都不能再次启动，代码演示详见CantStartTwice类）
2. 被加入线程组
3. 调用start()方法启动线程

注意点：

1. start方法是被synchronized修饰的方法，可以确保线程安全；
2. 由JVM创建的main方法线程和system组线程，并不会通过start来启动。

### native方法

native方法（由c或cpp编写），如果想看源码，去网站看openjdk实际实现

## 停止线程

### 原理介绍：

使用interrupt来通知，而不是强制停止线程（强制中断的线程，都是过期方法了，官方不推荐使用）

1.原理：用interrupt来请求、好处
2.想停止线程，要请求方、被停止方、子方法被调用方相互配合
3.最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况

如何处理不可中断的阻塞

1. 并没有通用的方法，针对特定的情况，使用特定的方法
2. 使用可以响应中断的方法

### Java中停止线程的原则是什么？

在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。

任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。然而,有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是运行超时或出错了。

要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断(Interruption),这是一种协作机制,能够使一个线程终止另一个线程的当前工作。

这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止,因为这种立即停止会使共享的数据结构处于不一致的状态。相反,在编写任务和服务时可以使用一种协作的方式:当需要停止时,它们首先会清除当前正在执行的工作,然后再结束。这提供了更好的灵活性,因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。

生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运的软件之间的最主要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。

### 中断sleep应该处理异常

#### 实际开发中的两种最佳实践：

1. 优先选择：传递中断（万金油）
2. 不想或无法传递：恢复中断（上一种不能用的情况下使用，不应屏蔽中断）

#### 传递中断：

添加异常到方法签名，在方法上抛出异常。用throws InterruptedException 标记你的方法，不采用try 语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，由于run方法内无法抛出checked Exception（只能用try catch），顶层方法必须处理该异常，避免了漏掉或者被吞掉的情况，增强了代码的健壮性。

例如：
```java
void subTask() throws InterruptedException
    sleep(delay);
}
```

#### 恢复中断

##### 如果不能抛出中断，要怎么做

如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法throws InterruptedException），那么应该选择在catch 子句中调用Thread.currentThread().interrupt() 来恢复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。  
代码演示详见视频，在这里，线程在sleep期间被中断，并且由catch捕获到该中断，并重新设置了中断状态，以便于可以在下一个循环的时候检测到中断状态，正常退出。  

##### 响应中断的方法总结列表

1. Object.wait()/wait(long)/wait(long,int)
2. Thread.sleep(long)/sleep(long,int)
3. Thread.join()/join(long)/join(long,int)
4. java.util.concurrent.BlockingQueue.take()/put(E)
5. java.util.concurrent.locks.Lock.lockInterruptibly()
6. java.util.concurrent.CountDownLatch.await()
7. java.util.concurrent.CyclicBarrier.await()
8. java.util.concurrent.Exchanger.exchange(V)
9. java.nio.channels.InterruptibleChannel相关方法
10. java.nio.channels.Selector的相关方法

##### 为什么要用interrupt来停止线程：

被中断的线程它本身拥有响应中断的权利，因为有些线程的某些代码是非常重要的，我们必须要等待这些线程处理完成之后或者他们准备好之后，再由他们自己去主动终止，或者它们真的不想理会我们的中断这也是完全ok的，我们不应该茹莽的使用stop方法，而是通过使用interrupt方法来发出一个信号，由它们自己处理，这样使我们的线程代码，在实际中更加安全，也完成了清理工作，数据的完整性也得到了保障

![](_v_images/20190903225518559_2071670296.png)

#### 异常

##### 非受检查异常：

Error:  
VirtualMachineError
AWTError

Exception:
RuntimeException

##### 受检查异常：

IOException

##### 错误停止方法：

1. 被弃用的stop,suspend和resume方法
2. 用volatile设置boolean标记位

##### 如何分析native方法

进入github（也可以进入 openJDK网站 ）
点“搜索文件”，搜索对应的c代码类Thread.c
找到native方法对应的方法名
去src/hotspot/share/prims/jvm.cpp里看cpp代码

![](_v_images/20190905205555461_716593482.png)

#### 停止线程相关重要函数解析

判断是否已被中断相关方法  

```java
static boolean interrupted()
//返回中断状态，并清除中断状态
return isInterrupted(true);
```

作用对象是当前运行它的线程，执行线程，该方法不关心被哪个对象调用，只关心执行它的线程


```java
boolean isInterrupted()

//返回中断状态
return isInterrupted(false);
```

Thread.interrupted()的目的对象  
Thread可看做this  

## 线程状态

线程的一生——6个状态（生命周期）
有哪6种状态 ？
每个状态是什么含义？
状态间的转化图示
阻塞状态是什么？

### 6种状态

1. New：已创建，但没启动，未执行Run方法
2. Runnable：调用了start方法，未分配资源也是此状态，Runnable可运行的，也可能是已运行中的
3. Blocked：进入synchronize修饰的代码块，仅synchronize
4. Waiting：
5. Timed Waiting
6. Terminated

### 阻塞状态

一般习惯而言，把Blocked（被阻塞）、Waiting（等待）、Timed_waiting（计时等待）都称为阻塞状态，不仅仅是Blocked

![](_v_images/20190907171200301_1137895628.png)


---

1.为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？

2.多种方式实现生产者模式

3.Join和sleep和wait期间线程的状态分别是什么？为什么？ 

|        |                               |                                                                                                                     |     
| ------ | ----------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| 类     | 方法名                        | 简介                                                                                                                |
| Thread | sleep相关                     | 本表格的“相关”，指的是重载方法，也就是方法名相同，但是参数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异 |
|        | join                          | 等待其他线程执行完毕                                                                                                |
|        | yield相关                     | 放弃已获取到的cpu资源                                                                                               |
|        | currentThread                 | 获取当前执行线程的引用                                                                                              |
|        | start,run相关                 | 启动线程相关                                                                                                        |
|        | interrupt相关                 | 中断线程                                                                                                            |
|        | stop(),suspend(),resume()相关 | 已废弃                                                                                                              |
| Object | wait/notify/notifyAll相关     | 让线程暂时休息和唤醒                                                                                                |

---

阻塞阶段
直到以下4种情况之一发生时，才会被唤醒
1.另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程；
2.另一个线程调用这个对象的notifyAll()方法；
3.过了wait(long timeout)规定的超时时间，如果传入0就是永久等待；
4.线程自身调用了interrupt()

唤醒阶段
notify唤醒一个（操作系统调度）
notifyAll唤醒全部

遇到中断

---

wait,notify,notifyAll特点、性质
1.用必须先拥有monitor
2.只能唤醒一个
3.属于Object类
4.类似功能的Condition
5.同时持有多个锁的情况

---

多种方式实现生产者消费者模式

为什么wait()需要在同步代码块内使用，而sleep()不需要？
主要是让通信变得可靠，防止死锁或者永久等待的发生，如果我们不把wait，notify都放在代码块里面，那么很有可能在它执行位置之前，线程突然切换到一个执行notify的线程 ，这样一来，对面的第二个线程，就把所有的notify代码都执行完毕了之后又切过来执行wait，没有synchronize保护，就可以在执行wait之前突然切换过去，这样会导致执行wait的线程永远不会被唤醒。 
而sleep是针对自己单独线程的，和其他线程关系不大

为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？
在java中wait，notify，notifyAll是锁级别的操作，而锁是属于每一个对象的，锁是绑定到每一个对象中，而不是线程中 ，同样的道理，我们反过来想，如果将w/n/n定义到Thread中，就会造成很大的局限性，经常我们会操作多把锁，如果定义在Thread中，就无法去实现这样灵活的逻辑了。

wait方法是属于Object对象的，那调用Thread.wait会怎么样？
Thread类非常特殊，在线程退出的时候会自动的调用notify，这样会使我们设计的流程受到干扰。

如何选择用notify还是notifyAll？

notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？
如果没有抢到，就会等待再次释放锁，或接受线程调度器的调度。

为什么弃用suspend()和resume()来阻塞线程？

---

sleep方法：
作用：我只想让线程在预期的时间执行，其他时候不要占用CPU资源，一旦调用sleep线程就会进入阻塞状态，就不会占用cpu资源。直到它下次被调度起来之后
特点：
不释放锁（包括synchronize和lock）
和wait不同，始终持有锁，而wait会释放锁

sleep方法响应中断
1.抛出InterruptedException
2.清除中断状态

sleep第二种写法（更优雅）：TimeUnit

sleep方法可以让线程进入Waiting状态，并且不占用cpu资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态

wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）
相同：
1.wait和sleep方法都可以使线程阻塞，对应线程状态是waiting或time_waiting。
2.wait和sleep方法都可以响应中断Thread.interrupt（）。
不同：
1.wait方法的执行必须在同步方法中进行，而sleep则不需要。
2.在同步方法里执行sleep方法时，不会释放monitor锁，但是wait方法会释放monitor锁。
3.sleep方法短暂休眠之后会主动退出阻塞，而没有指定时间的wait方法则需要被其他线程中断后才能退出阻塞。
4.wait()和notify()，notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法。


---

join方法作用、用法
作用：因为新的线程加入了我们，所以我们要等他执行完再出发
用法：main等待thread1执行完毕，注意谁等谁

join注意点
CountDownLatch或CyclicBarrier类

在join期间，线程处于哪种线程状态？
WAITING

---

yield方法
作用：释放我的CPU时间片，但是不会释放锁，也不会陷入阻塞
定位：JVM不保证遵循，为了保证程序的稳定性，一般开发中不使用yield，但是这个方法，并发包的类中运用的场合比较多。

yield与sleep区别：是否随时可能再次被调度

---

什么时候我们需要设置守护线程？

我们应该如何应用线程优先级来帮助程序运行？有哪些禁忌？

不同的操作系统如何处理优先级问题？

---

线程各属性

线程各属性纵览：
1.线程id：每个线程有自己的id，用于标识不同的线程
2.线程名字name：作用让用户或程序员在开发、调试或运行过程中，更容易区分每个不同的线程、定位问题等。
3.守护线程isDaemon：true代表该线程是【守护线程】，false代表线程是非守护线程，也就是【用户线程】。
4.线程优先级Priority：优先级这个属性的目的是告诉线程调度器，用户希望哪些线程相对多运行、哪些少运行。

java只有以下两种情况发生，程序才能结束：
1.调用system.exit()
2.代码执行完毕

守护线程
例子：垃圾处理器
作用：给用户线程提供服务
特性：
1.线程类型默认继承自父线程
2.被谁启动
3.不影响JVM退出

main非守护线程

守护线程和普通线程的区别：
整体无区别
唯一区别在于影响JVM退出

我们是否需要给线程设置为守护线程？
不安全，可能造成数据不一致

---

线程优先级
10个级别、默认5
MIN_PRIORITY=1
NORM_PRIORITY=5
MAX_PRIORITY=10
程序设计不应该依赖于优先级：
1.不同操作系统不一样，优先级高度依赖操作系统，java通常会把优先级映射到操作系统的优先级上。最终的调度最终依赖于操作系统。例如windows优先级有7级：windows中的1,2级对应java中的最低级，3、4对应次中级，5对应通常级别norm级别。java是一次编
 写多平台运行，在linux中优先级会被忽略，所有级别都是一样的。Solaris中有2的32次方优先级。
2.优先级会被操作系统改变，windows中有一个优先级推进器的功能，当其发现某个线程特别努力想执行的话，那么就会越过优先级的设置，优先为其分配时间，这样一来设置的优先级就不起作用了。如过一个优先级设置的过低，会发生饥饿，很长时间不会运行

---

java异常体系图
实际工作中，如何全局处理异常？为什么要全局处理？不处理行不行？

UncaughtExceptionHandler

为什么使用UncaughtE  xceptionHandler？
主线程可以轻松发现异常，而子线程却不行
子线程异常无法用传统方法捕获
不能直接捕获的后果、提高健壮性

两种解决方法：
方案一（不推荐）：手动在每个run方法里进行try catch
方案二（推荐）：利用UncaughtExceptionHandler

UncaughtExceptionHandler接口
void uncaughtException(Thread t,Throwable e)

异常处理器的调用策略

源码：
![](_v_images/20190917232013255_373651365.png)


实现：
给程序统一设置
给每个线程单独设置
给线程池设置

run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？

线程中如何处理某个未处理异常？

一共有那几种线程安全问题？

什么是多线程的上下文切换？

---

线程安全：
《Java Concurrency In Practice》的作者Brian Goetz对“线程安全”有一个比较恰当的定义：“当多个线程访问一个对象时，如歌不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。
这句话的意思是：不管业务中遇到怎样的多个线程访问某对象或某方法的情况，而在编程这个业务逻辑的时候，都不需要额外做任何额外的处理（也就是可以像单线程编程一样），程序也可以正常运行（不会因为多线程而出错），就可以称为线程安全。
相反，如果在编程的时候，需要考虑这些线程在运行时的调度和交替（例如在get()调用期间不能调用set()），或者需要进行额外的同步（比如使用synchronized关键字等），那么就是线程不安全的。

---

全都线程安全？
运行速度、设计成本、trade off
完全不用于多线程：不过度设计

什么情况下会出现线程安全问题，怎么避免？
运行结果错误：a++多线程下出现消失的请求现象
活跃性问题：死锁、活锁、饥饿
对象发布和初始化的时候的安全问题

---

![](_v_images/20190919213223447_631956148.png =829x)

原子类：cas