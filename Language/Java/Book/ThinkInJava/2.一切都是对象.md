# 2.一切都是对象

1.每种编程语言都有自己的数据处理方式。有些时候，程序员必须时刻留意准备处理的是什么类型。您曾利用一些特殊语法直接操作过对象，或处理过一些间接表示的对象吗（C或C++里的指针）？
所有这些在Java里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，任何地方均可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“句柄”（Handle）。在其他Java参考书里，还可看到有的人将其称作一个“引用”，甚至一个“指针”。可将这一情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对电视机的控制，那么手上拿着的是遥控板，而非电视机。
此外，即使没有电视机，遥控板亦可独立存在。也就是说，只是由于拥有一个句柄，并不表示必须有一个对象同它连接。所以如果想容纳一个词或句子，可创建一个String句柄：
String s;
但这里创建的只是句柄，并不是对象。若此时向s发送一条消息，就会获得一个错误（运行期）。这是由于s实际并未与任何东西连接（即“没有电视机”）。因此，一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：
String s = "asdf";
然而，这里采用的是一种特殊类型：字串可用加引号的文字初始化。通常，必须为对象使用一种更通用的初始化类型。



2.创建句柄时，我们希望它同一个新对象连接。通常用new关键字达到这一目的。new的意思是：“把我变成这些对象的一种新类型”。所以在上面的例子中，可以说：
String s = new String("asdf");
它不仅指出“将我变成一个新字串”，也通过提供一个初始字串，指出了“如何生成这个新字串”。
当然，字串（String）并非唯一的类型。Java配套提供了数量众多的现成类型。对我们来讲，最重要的就是记住能自行创建类型。事实上，这应是Java程序设计的一项基本操作，是继续本书后余部分学习的基础。


3.程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：
(1) 寄存器。这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。
(2) 堆栈。驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些Java数据要保存在堆栈里——特别是对象句柄，但Java对象并不放到其中。
(3) 堆。一种常规用途的内存池（也在RAM区域），其中保存了Java对象。和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！
(4) 静态存储。这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。
(5) 常数存储。常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。
(6) 非RAM存储。若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。Java 1.1提供了对Lightweight persistence的支持。未来的版本甚至可能提供更完整的方案。



3.基本类型：在程序设计中经常用到一系列类型，他们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为new将对象存储在“堆”里，故用New创建一个对象——特别是小的，简单的变量，往往不是很有效。因此，对于这些类型，java采取与C和C++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。



4.java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是java程序比用其他大多数语言编写的程序更具可移植性的原因之一。


5.boolean 包装器类型Boolean。
char:16-bit,Unicode0至Unicode2^16-1,包装器类型Character.
byte:8bits,-128至+127，包装器类型Byte.
short:16bits，-2^15至+2^15-1,包装器类型Short.
int:32bits,-2^31至+2^31-1,包装器类型Integer.
long:64bits,-2^63至+2^63-1,包装器类型Long.
float:32bits,IEEE754至IEEE754,包装器类型Float.
double:64bits,IEEE754至IEEE754,包装器类型Double.
void:包装器类型Void.


6.基本类型具有的包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。
例如:char c='x';Character ch = new CHaracter(c);Java SE5的自动包装功能将自动地将基本类型转换为包装器类型：Character ch = 'x';并可以反向转换:char c= ch;



7.高精度数字
BigInteger支持任意精度的整数。
BigDecimal支持任何精度的定点数。

8.字段和方法：一旦定义了一个类（在Java中你所做的全部工作就是定义类，产生那些类的对象，以及发送消息给这些对象），就可以在类中设置两种类型的元素：字段（有时被称作数据成员）和方法（有时被称作成员函数）。如果字段是对某个对象的引用，那么必须初始化该引用，以便使其与一个实际的对象（如前所述，使用new来实现）相关联。


9.若类的某个成员是基本数据类型，即使没有进行初始化，java也会确保它获得一个默认值，当变量作为类的成员使用时，java才确保给定其默认值，以确保那些是基本类型的成员得到初始化（CPP没有此功能），防止产生程序错误。但是，这些初始值对你的程序来说，可能是不正确的，甚至是不合法的。所有最好名器对变量进行初始化。然而上述确保初始化的方法并不适用于“局部”变量（即并非某个类的字段）。因此，如果在某个方法定义中有 int x；那么变量x得到的可能是任意值（与C与C++中一样），而不会被自动初始化为零。所有在使用x前，应先对其赋一个适当的值。如果忘记了这么做，java会在编译时返回一个错误，告诉你此变量没有初始化，这正是JAVA优于C++的地方（许多C++编译器会对未初始化变量给予警告，而java则视为是错误）。


10.方法的基本组成部分：名称，参数，返回值，方法体。

11.方法的参数列表指定要传递给方法什么样的信息。正如你可能料想的那样，这些信息像java中的其他信息一样，采用的都是对象形式。因此，在参数列表中必须指定每个所传递对象的类型及名字。想java中任何传递对象的场合一样，这里传递的实际也是引用，并且引用的类型必须正确。如果参数被设为String类型，则必须传递一个String对象；否则，编译器将抛出错误。


12.return代表“已经做完，离开此方法”。其次，如果此方法产生了一个值，这个值要放在return语句后面。


13.通常来说，当创建类时，就是在描述那个类的对象的外观与行为。除非用new创建那个类的对象，否则，实际上并未获得任何对象。执行new来创建对象时，数据存储空间才被分配，其方法才供外界调用。有两种情形用上述方法是无法解决的。一种情形是，只想为某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情形是，希望某个方法不与包含它的类的任对象关联在一起。也就是说，即使没有创建对象，也能够调用这个方法。通过static关键字可以满足这两方面的需求。当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所有，即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域。通常，你必须创建一个对象，并用它来访问数据或方法。因为非static域和方法必须知道它们一起允在的特定对象。


14.在进行编译时，/*和*/之间的所有东西都会被忽略。

