# 3.操作符

1.操作符优先级：先乘除后加减。

2.赋值使用操作符“=”。它的意思是“取右边的值（即右值），把它复制给左边（即左值）”。右值可以是任何常数，变量或者表达式（只要它能生成一个值就行）。但左值必须是一个明确的，已命名的变量，也就是说，必须有一个物理空间可以存储等号右边的值。但是不能把任何东西赋给一个常数，常数不能作为左值。对基本数据类型的赋值是简单的。基本类型存储了实际的数值，而并非指向一个对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到了另一个地方。若接着又修改了a，而b根本不会受这种修改的影响。作为程序员，这正是大多数情况下我们所期望的。但是在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是对对象都得引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着假若对对象使用c=d，那c和d都指向原本只有d指向的那个对象。

3.java的基本算法操作符与其他大多数程序设计语言是相同的。其中包括加号（+）,减号（-）,除号（/）,乘号（*）以及取模操作符（%，它从整数除法中产生余数）。整数除法会直接去掉结果的小数位，而不是四舍五入地完整结果。

4.一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小类型的操作数提升为int。（自动窄化操作）

5.递增和递减运算是两种相当不错的快捷运算。其中，递减操作符是“--”，意为“减少一个单位”；递增操作符是“++”，意为“增加一个单位”。举个例子来说吗，假设a是一个int（整数）值，则表达式++a就等价与（a=a+1）。递增和递减操作符不仅改变了变量，并且以变量的值作为生成的结果。这两个操作符各有两种使用方式，通常称为“前缀式”和“后缀式”。“前缀递增”表示“++”操作符位于变量或表达式的前面；而“后缀递增”表示“++”操作符位于变量或表达式的后面。类似的吗，“前缀递减”意味着“--”操作符位于变量或表达式的前面；而“后缀递减”意味着“--”操作符位于变量或表达式的前面；而“后缀递减”意味着“--”操作符位于变量或表达式的后面。对于前缀递增和前缀递减（如++1或--a），会先执行运算，在生成值。而对于后缀递增和后缀递减（如a++或a--），会先生成值，在执行运算。

6.“==”和“！=”比较的是对象的引用。如果想比较两个对象的实际内容是否相同，此时，必须使用所有对象都适用的特殊方法equals()。但这个方法不适用于“基本类型”，基本类型直接使用==和！=即可。大多数java类库都实现了equals()方法，以便用来比较对象的内容，而非比较对象的引用。

7.逻辑操作符“与”（&&），“或”（||），“非”（！）能根据参数的逻辑关系，生成一个布尔值（true||false）。“与或非”操作只可应用于布尔值。与在C及C++中不同的是：不可将一个非布尔值当作布尔值在逻辑表达式中使用。“//! print()”就是错误的用法。

8.逻辑短路：当使用逻辑操作符时，我们会遇到一种“短路”现象。即一旦能够明确无误地确定整个表达式的值，就不再计算表达式余下部分了。因此，整个逻辑表达式靠后的部分有可能不会被运算。 class{test1(){return true};test2(){return false;test3(){return false};};main(){boolean b=test1()&&test2()}}/*test2,3不执行*/。你会很自然地认为所有这三个测试都会得以执行。但输出显示却并非这样。第一个测试生成着结果true，所以表达式计算会继续下去。然而，第二个测试产生了一个false结果。由于这意味着整个表达式肯定为false，所以没必要继续计算剩余的表达式，那样只是浪费。“短路”一词的由来正源于此。事实上，如果所有的逻辑表达式都有一部分不必计算，那将获得潜在的性能提升。


9.直接常量后面的后缀字符标志了它的类型。若为大写（或小写）的L，代表long（但是，使用小写字母l容易造成混淆，因为它看起来很像数字1）。大写（或小写）字母F，代表float；大写（或小写）字母D，则代表double。十六进制数适用于所有整数数据类型，以前缀0x（或0X），后面跟随0-9或小写（或大写）的a-f来表示。如果试图将一个变量初始化成超出自身表示范围的值（无论这个值得数值形式如何），编译器都会向我们报告一条错误信息。注意在前面的代码中，已经给出了char，byte以及short所能表达的最大的十六进制值。如果超出范围，编译器会将值自动转换成int型，并告诉我们需要对这次赋值进行“窄化转型”。这样我们就可清楚地知道自己的操作是否越界了。八进制数由前缀0以及后续的0~7的数字来表示。在C，C++或者Java中，二进制数没有直接常量表示方法。但是，在使用十六机制和八进制计数法时，以二进制形式显示结果将非常有用。通过使用Integer和Long类的静态方法toBinaryString()方法，则该类型将自动被转化为int。

10.按位操作符用来操作整数基本数据类型中的单个“比特”（bit），即二进制位。按位操作符会对两个测试中对应的位执行布尔代数运算，并最终生成一个结果。按位操作符来源于C语言面向底层的操作，在这种操作中经常需要直接操纵硬件，设置硬件寄存器内的二进制位。如果两个输如位都是1，则按位“与”操作符（&）生成一个输出位1，否则生成一个输出位0.如果两个输入位里只有一个是1，则按位“或”操作符（|）生成一个输出位1，但不全是1，那么按位“异或”操纵（^）生成一个输出位1.按位“非”（~）,也称为反操作符，它属于一元操作符，只对一个操作数进行操作（其他按位操作符是二元操作符）。按位“非”生成与输入位相反的值——若输入0，则输出1；若输入1，则输出0.按位操作符和逻辑操作符都使用了同样的符号，因此我们能方便地记住它们的含义：由于位是非常“小”的，所以按位操作符仅使用了一个字符。按位操作符可与等号（=）联合使用，以便合并运算和赋值：&=，|=和^=都是合法的（由于“~”是一元操作符，所以不可与“=”联合使用）。我们将布尔类型作为一种单比特值对待，所以它多少有些独特。我们可对它执行按位“与”，按位“或”和按位“异或”运算，但不能执行按位“非”（大概是为了避免与逻辑not混淆）。对于布尔值，按位操作符具有与逻辑操作符相同的效果，只是它们不会中途“短路”。此外，针对布尔值进行的按位运算为我们新增了一个“异或”逻辑操作符，它并未包括在“逻辑”操作符的列表中。在移位表达式中，不能使用布尔运算。

11.移位操作符操作的运算对象也是二进制的“位”。移位操作符只可用来处理整数类型（基本类型的一种）。左移位操作符（<<）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）。“有符号”右移位操作符（>>）则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”；若符号为正，则在高位插入0；若符号位负，则在高位插入1。java中增加了一种“无符号”右移动操作符（>>>），它使用“零扩展”；无论正负，都在高位插入0.这一操作符是C或C++中所没有的。如果对char，byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转换为int类型，并且得到的结果也是一个int类型的值。只有数值右端的低5位才有用。这样可放在我们移位超过int型值所具有的位数。（因为2的5次方为32，而int型值只有32位。）若对一个long类型的数值进行处理，最后得到的结果也是long。此时只会用到数值右端的低6位，以防止位移超过long型数值具有的位数。“移位”可与“等号”（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋给左边的变量。但在进行“无符号”右移位结合赋值操作时，可能遇到一个问题：如果对byte或short值进行这样的位移运算，得到的可能不是正确的结果。它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。


12.三元操作符也称为条件操作符，它显得比较特别，因为它有三个操作数；但它确实属于操作符的一种，因为它最终也会生成一个值。其表达式采取下述形式：boolean-exp?value0:value1如果boolean-exp（布尔表达式）的结果为true，就计算value0，而且这个计算结果也就是操作符最终产生的值。如果boolean-exp的结果为false，就计算value1，同样，它的结果也就成为了操作符最终产生的值。


13.字符串操作符有一些很有趣的行为。如果表达式以一个字符串起头，那么后续所有操作数都必须是字符串型（请记住，编译器会把双引号内的字符序列自动转成字符串）


14.java中有一个与C和C++中类似的问题，即使用按位“与”和按位“或”代替逻辑“与”和逻辑“或”。按位“与”和按位“或”使用单字符（&或|），而逻辑“与”和逻辑“或”使用双字符（&&或||）。就像“=”和“==”一样，键入一个字符当然要比键入两个简单。java编译器可防止这个错误发生，因为它不允许我们随便把一种类型当作另一种类型来用。


15.类型转换（cast）的愿意是“模型铸造”。在适当的时候，java会将一种数据类型自动转换成另一种。例如，假设我们为某浮点变量赋予以一个整数值，编译器会将int自动转换为float。类型转换运算允许我们显示地进行这种类型的转换，或者在不能自动进行转换的时候强制进行类型转换。应避免窄化转换。


16.在进行窄化转换时，必须注意结尾和舍入问题。如果想要得到舍入的结果，就需要使用java.lang.math中的rounde()方法。


17.提升:如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char，byte或者short），那么在运算之前，这些值会自动转换为int。这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转换（既然把结果赋给了较小的类型，就可能出现信息丢失）。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。如果将一个float值与一个double值相乘，结果就是double；如果将一个int和一个long值相加，则结果为long。

