# 5.初始化与清理

1.初始化和清理（cleanup）正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。特别是在使用程序库时，如果用户不知道如何初始化库的构件（或者是用户必须进行初始化其他东西），更在此时。清理也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一直得不到释放，结果是资源（尤其是内存）用尽。

2.C++引用了构造器（constructor）的概念，这是一个在创建对象时被自动调用的特殊方法。java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。

3.在创建对象时：new Rock（）；将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。

4.不接受任何参数的构造器叫做默认构造器，java文档中通常使用术语无参构造器，但是默认构造器在JAVA出现之前已经使用许多年了，所以我仍旧倾向于使用它。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。

5.构造器有助于减少错误，并使代码更易于阅读。从概念上讲，“初始化”与“创建”是彼此独立的，然而在上面的代码中，你却找不到队initalize（）方法的明确调用。在java中，“初始化”和“创建”捆绑在一起，两者不能分离。构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空（void）明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西。构造器则不会返回任何东西，你别无选择（new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值）。并且允许人们自动选择返回类型，那么势必得让编译器知道该如何处理此返回值。

6.涉及基本类型的重载：基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此过程一旦牵涉到重载，可能会造成一些混淆。如果传人的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升。如果传入的实际参数较大，就得通过类型转换来执行窄化转换（非自动）。否则就会报错。

7.默认构造器（无参构造器）是没有形式参数的——它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。但是，如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。这就好比，要是你没有提供任何构造器，编译器会认为“你需要一个构造器，让我给你制造一个吧”；但假如你已写了一个构造器，编译器怎会认为“啊，你已写了一个构造器，所以你知道你在做什么，你是刻意省略了默认构造器。”


8.假设你希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：this。this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的this引用会自动应用于同一个类中的其他方法。


9.在构造器中调用构造器：可能为一个类写了多个构造器，有时可能想在构造器中调用另一个构造器，以避免重复代码。可用this关键字做到这一点。通常写this的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用。

10.static含义：了解this关键字之后，就能更全面地理解static（静态）方法的含义。static方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来倒是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。它很像全局方法。java中禁止使用全局方法，但你在类中置入static方法就可以访问其他static方法和static域。有些人认为static方法不是“面向对象”的，因为它们的确具有全局函数的语义；使用static方法时，由于不存在this，所以不是通过“面向对象发送消息”的方式来完成的。的确，要是在代码中出现了大量的static方法，就该重新考虑自己的设计了。然而，static的概念有其实用之处，许多时候都在用到它。至于它是否真的“面向对象”，就留给理论家去讨论吧。事实上，Smalltalk语言里的“类方法”就是与static方法相对应的。



11.Java尽力保证：所有变量在使用前得到恰当地初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。所有如果写成void f(){int i;i++;//Error -- i not initialized }就会得到一条出错消息，告诉你i可能尚未初始化。当然，编译器也可以为i赋一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。一次强制程序员提供一个初始值，往往能够帮助找出程序里的缺陷。要是类的数据成员（即字段）是基本类型，情况就会变得有些不同。正如在“一切都是对象”一章中所看到的，类的每个基本类型数据成员保证都会有一个初始值。在类中定义一个对象引用时，如果不将其初始化，此引用就会获得一个特殊值null。


13.在类的内部，变量定义的先后顺序决定了初始化的循序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。


14.无论创建多少个对象，静态数据都只占用一份存储数据。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化值就是null。如果想在定义处进行初始化，采取的方法与非静态数据没什么不同。

15.初始化的顺序是先静态对象（如果他们尚未因前面的对象创建过程而被初始化），而后是“非静态”对象。

16.对象的创建过程,假设有个名为Dog的类：
（1）即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找路径，以定位Dog.class文件。
（2）然后载入Dog.class（后面会学到，这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
（3）当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
（4）这块存储空间会被清零 ，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值（对数字来说就是0，对布尔型和字符型也相同），而引用则被设置成了null。
（5）执行所有出现于字段定义处的初始化动作。
（6）执行构造器。


17.Java允许将多个静态初始化动作组成一个特殊的“静态子句”（有时也叫做“静态块”）。如下：public class Spoon{static int i; static {i=47;}}尽管上面的代码看起来像个方法，但它实际只是一段跟在static关键字后面的代码。与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个累的对象）。


18.非静态实例初始化：Java中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。如下：{int i;}看起来它与静态初始化子句一模一样，只不过少了static关键字。这种语法对于支撑“匿名内部类”的初始化是必须的，但是它也使得你可以保证无论调用了哪个显示构造器，某些操作都会放生。从输出中可以看到实例初始化子句是在两个构造器之前执行的。


20.可变参数列表（C通常把它简称为varargs）:可应用与参数个数或类型未知的场合。由于所有的类都是自己或间接继承于Object类，所以可以创建以Object数组为参数的方式。有了可变参数，就再也不用显示地编写数组语法了，当你指定参数时，编译器实际上会为你去填充数组。你获取的仍旧是一个数字。static void printArray(Object... args){foreach};


21.Java垃圾回收器只知道释放那些经由new分配的内存，假定你的对象（并非使用new）获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存。为了应对这种情况，Java允许在类中定义一个名为finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收冬至发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。


22.析构与finalize区别（C++中，如果程序中没有缺陷的话，对象一定会被销毁；而java里的对象却并非总是被垃圾回收。）：(1)对象可能不被垃圾回收。(2)垃圾回收并不等于“析构”(3)垃圾回收只与内存有关。


23.垃圾回收器如何工作：在以前所用过的程序语言中，在堆上分配对象的代价十分高昂，因此读者自然会觉得Java中所有对象（基本类型除外）都在堆上分配的方式也十分高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。听起来很奇怪——存储空间的释放竟然会影响存储空间的分配，但这却是是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度，可以和其他语言从堆栈山个分配空间的速度相媲美。