# 7,8,9.综合（继承、接口、多态、复用）

一.复用类

1.继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。组合的语法比较平实，但是继承使用的是一种特殊的语法。在继承过程中，需要先声明“新类与旧类相似”。这种声明是通过在类主体的左边花括号之前，书写后面紧随基类名称的关键字extends而实现的。当这么做时，会自动得到基类中所有的域和方法(final类除外)。


2.Java用super关键字表示超类的意思，当前类就是从超类继承来的。为此，表达式super.method()将调用基类版本的方法。


3.代理，Java并没有提供对它的直接支持。这是继承与组合的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴漏了该成员对象的所有方法（就像继承）。


4.通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。如果确实遇到清理的问题，那么必须用心为新类创建清理方法。并在方法中调用基类的清理方法。


5.protected关键字：现在，我们已介绍完了继承，关键字protected最终具有了意义。在理想世界中，仅靠关键字private就已经足够了。但在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但仍然允许导出类的成员访问它们。关键字protected就是起这个作用。它指名“就类用户而言，这是private的，但对于继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的（protected也提供了包内访问权限。）。”尽管可以创建protected域，但是最好的方法还是将域保持为private；你应当一致保留“更改底层实现”的权利。然后通过protected方法来控制类的继承者的访问权限。


6.编译器并不是简单地为每一个引用都创建默认对象，这一点是很有意义的，因为若真要那样做的话，就会在许多情况下增加不必要的负担。如果想初始化这些引用，可以在代码中的下列位置进行：
(1)在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。
(2)在类的构造器中。
(3)就在正要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外的负担。
(4)使用实例初始化。


7.初始化的实际过程：
(1)在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。
(2)如前所述那样调用基类构造器。
(3)按照声明的顺序调用成员的初始化方法。
(4)调用导出类的构造器主体。


8.继承初始化顺序：
(1)调用基类构造器。这个步骤会不断地反复递归下去，首先是构造器这种层次结构的根，然后是下一层导出类，等待，直到最低层的导出类。
(2)按声明顺序调用成员的初始化方法。
(3)调用导出类构造器的主体。


9.构造器的调用顺序是很重要的。当进行继承时，我们已经知道基类的一切，并且可以访问基类中的任何声明为public和protected的成员。这意味着在导出类中，必须假定基类的所有成员都是有效的。一种标准方法是，构造动作一经发生，那么对象所有部分的全体成员都会得到构建。然而，在构造器内部，我们必须确保所要使用的成员都已经构建完毕。为确保这一目的，唯一的办法就是首先调用构造器。那么构造器中的所有成员都有效也是因为，当成员对象在类内进行定义的时候,只要有可能，就应该对它们进行初始化（也就是说，通过组合方法将对象置于类内）。若遵循这一规则，那么就能确保所有基类成员以及当前对象的成员对象都被初始化了。


10.基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每个基类的构造器都能得到调用。这样做是有意义的，因为构造器具有一项特殊任务：检查对象是否被正确地构造。导出类智能访问它自己的成员，不能访问基类中的成员（基类成员通常是private类型）。只有基类的构造器才具有恰当的知识和权限来对自己的元素初始化。因此，必须令所有构造器都得到调用，否则就不可能正确构造完整对象。这正是编译器为什么要强制每个导出类部分都必须调用构造器的原因。在导出类的构造器主体中，如果没有明确指定调用某个基类构造器，它就会“默默”地调用默认构造器。如果不存在默认构造器，编译器就会报错（若某个类没有构造器，编译器会自动合成出一个默认构造器）。


11.如果编译器注意到它有一个基类（这是由关键字extends得知的），于是它继续进行加载。不管你是否打算产生一个该基类的对象，这都要发生。如果该基类还有其自身的基类，那么第二个基类就会被加载，如此类推。接下来，根基类中的static初始化即会被执行，然后是下一个导出类，以此类推。这种方式很重要，因为导出类的static初始化可能会依赖于基类成员能否被正确初始化。至此为止，必要的类都已加载完毕，对象就可以被创建了。首先，对象中所有的基本类型都会被设为默认值，对象引用被设为null——这是通过将对象内存设为二进制零值而一举生成的。然而，基类的构造器会被调用。在本例中，它是被自动调用的。但也可以用super来指定对基类构造器的调用。基类构造器和导出类的构造器一样，以相同的顺序来经历相同的过程。在基类构造器完成之后，实例变量按其次序被初始化。最后，构造器的其余部分被执行。


12.在清理方法中，还必须注意对基类清理方法和成员对象清理方法的调用顺序，以防止某个子对象依赖于另一个子对象情形的发生。一般而言，所采用的形式应该与C++编译器在析构函数上所施加的形式相同：首先，执行类的所有特定的清理动作，其顺序同生成顺序相反（通常这就要求基类元素仍旧存活）；然后，就如我们所示范的那样，调用基类的清理方法。许多情况下，清理并不是问题，仅需让垃圾回收器完成该动作就行。但当必须亲自处理清理时，就得多做努力并多加小心。因为，一旦涉及垃圾回收，能够信赖的事就不会很多了。垃圾回收器可能永远也无法被调用，即使被调用，它也可能以任何它想要的顺序来回收对象。最好的办法是除了内存以外，不能依赖垃圾回收器去做任何事。如果需要进行清理，最好是编写你自己的清理方法，但不要使用finalize()。(看第4章初始化)


13.销毁的顺序应该和初始化顺序相反。对于字段，则意味着与声明的顺序相反（因为字段的初始化时按照声明的顺序进行的）。对于基类（C++中析构函数的形式），应该首先对其导出类进行清理，然后才是基类。这是因为导出类的清理可能会调用基类中的某些方法，所以需要使用基类中的构件仍起作用而不应该过早地销毁它们。



14.“为新的类提供方法”并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句加以概况。


15.在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。略微思考一下就会发现，用一个“交通工具”对象来构成一部“车子”是毫无意义的，因为“车子”并不包含“交通工具”，它仅是一种交通工具（is-a关系）。“is-a”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。


16.为什么称为向上转型：该术语的使用有其历史原因，并且是以传统的类继承图的绘制为基础的：将根基于页面顶端，然后逐渐向下。（当然也可以以任何你认为有效的方法进行绘制。）：由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。由于向上转型是从一个较专用类型向较通用类型转换，所有总是很安全的。也就是说，导出类是基类的一个超集。它可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在“未曾明确表示转型”或“未曾制定特殊标记”的情况下，仍然允许向上转型的原因。


15.采取“纯粹”的方式来创建继承层次结构似乎是最好的方式。也就是说，只有在基类中已经建立的方法才可以在导出类中被覆盖，这被称作是纯粹的“is-a”(是一种)关系，因此一个类的接口已经确定了它应该是什么。继承可以确保所有的导出类具有基类的接口，且绝对不会少。也可以认为这是一种村替换，因为导出类可以完全代替基类，而在使用它们时，完全不需要知道关于子类的任何额外信息：也就是说，基类可以接受发送给导出类的任何消息，因为二者有着完全相同的接口。我们只需从导出类向上转型，永远不需知道正在处理的对象的确切类型。所有这一切，都是通过多态来处理的。按这种方式考虑，似乎只有纯粹的is-a关系才是唯一明智的做法，而所有其他的设计都只会导致混乱和注定会失败。这其实也是一个陷阱，因为只要开始考虑，就会转向，并发现扩展接口(遗憾的是，extends关键字似乎在怂恿我们这样做)才是解决特定问题的完美方案。这可以称为“is-like-a”(像一个)关系，因为导出类就像是一个基类——它有着相同的基本接口，但是它还具有由额外方法实现的其他特性。虽然这是一种有用且明智的方法（依赖于具体情况），但是它也有缺点。导出类中接口的扩展部分不能被基类访问，因此，一旦我们向上转型，就不能调用那些新方法：在这种情况下，如果我们不进行向上转型，这样的问题也就不会出现。但是通常情况下，我们需要重新查明对象的确切类型，以便能够访问该类型所扩充的方法。


16.由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，所以我们就想，通过向下转型——也就是在继承层次中向下移动——应该能够获取类型信息。然而，我们知道向上转型是安全的，因为基层不会具有大于导出类的接口。因此，我们通过基类接口发送的消息保证都能被接受。但是对于向下转型，例如，我们无法知道一个“几何形状”它确实就是一个“圆”，它可以是一个三角形，正方形或其他一些类型。要解决这个问题，必须有某种方法来确保向下转型的正确性，使我们不致于贸然转型到一种错误类型，进而发出该对象无法接受的消息。这样做是极其不安全的。在某些程序设计语言（如C++）中，我们必须执行一个特殊的操作来获得安全的向下转型。但是在Java语言中，所有转型都会得到检查！所以即使我们只是进行一次普通的加括弧形式的类型转换，在进入运行期时仍然会对其进行检查，以便保证它的确是我们希望的那种类型。如果不是，就会返回一个ClassCastException（类转型异常）。这种爱运行期间对类型进行检查的行为称作“运行时类型识别”(RTTI)。


27.“覆盖”只有在某方法是基类的接口的一部分时才会出现。即，必须能够将一个对象向上转型为它的基本类型并调用相同的方法。如果其方法是private，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。但如果在导出类中以相同的名称生成一个public，protected或访问权限方法的话，该方法就不会产生在基类中出现的“仅具有相同名称”的情况。此时你并没有覆盖该方法，仅是生成了一个新的方法。由于private方法无法触及而且能有效隐藏，所以除了把它看成是因为它所归属的类的组织结构的原因而存在外，其他任何事物都不需要考虑到它。
-------------------------------------------------------------------------------------------------------------------------------
二.多态

1.多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可扩展的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。


2.前期绑定：将一个方法调用同一个方法主体关联起来被称为绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做前期绑定。


3.后期绑定：在运行时根据对象的类型进行绑定。后期绑定也叫动态绑定或运行时绑定。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。后期绑定机制随编程语言的不同而有所不同，但是只要想一下就会得知，不管怎样都必须在对象中安置某种“类型信息”。


4.Java中除了static方法final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着通常情况下，我们不必判定是否应该进行后期绑定——它会自动发生。


5.一旦你了解多态机制，可能就会开始任务所有事物都可以多态地发生。然而，只有普通的方法调用可以是多态的。例如，如果你直接访问某个域，这个访问就将在编译器进行解析。


6.当导出类对象转型为基类引用时，任何域访问操作都将由编译器解析，因此不是多态地。在本例中，为Super.a和Sub.a分配了不同的存储空间。这样，Sub实际上包含两个称为a的域：它自己的和它从Super处得到的。然而，在引用Sub中的a时所产生的默认域并非Super版本的a域。因此，为了得到Super.field，必须显式地指明super.a。尽管这看起来好像会成为一个令人混淆的问题，但是在实践中，它实际上从来不会发生。首先，你通常会将所有的域都设置成private，因此不能直接访问它们，其副作用是只能调用方法来访问。另外，你可能不会对基类中的域和导出类中的域赋予相同的名字，因此这种做法容易令人混淆。

-------------------------------------------------------------------------------------------------------------------------------
三.接口


1.包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。


2.如果从一个类继承，并想创建该类的对象，那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做（可以选择不做），那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。


2.如果一个抽象类不完整，那么当我们试图产生该类的对象时，编译器会怎样处理呢？由于位抽象类创建对象时不安全的，所以我们会从编译器那里得到一条出错消息。这样，编译器会确保抽象类的纯粹性，我们不必担心会误用它。如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做（可以选择不做），那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字限定这个类。我们也可能会创建一个没有任何抽象方法的抽象类。考虑这种情况：如果有一个类，让其包含任何abstract方法都显得没有实际意义，而且我们也想要阻止这个类的任何对象，那么这时这样就很有用了。


3.interface关键字使抽象类的概念更向前迈进了一步。abstract关键字允许人们在类中创建一个或多个没有任何定义的方法——提供了接口部分，但是没有提供任何相应的具体实现，这些实现是由此类的继承者创建的。interface这个关键字产生了一个完全抽象的类，它根本就没有提供任何具体实现。它允许创建者确定方法名，参数列表和返回类型，但是没有任何方法体。接口只提供了形式，而未提供任何具体实现。


4.一个接口表示：“所有实现了该特定接口的类看起来都像这样”。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。因此，接口被用来建立类与类之间的协议。（某些面相对象编程语言使用关键字protocol来完成这一功能。）但是，interface不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继变种的特性。


5.想要创建一个接口，需要用interface关键字来替代class关键字。就像类一样，可以在interface关键字前面添加public关键字（但仅限于该接口在与其同名的文件中被定义）。如果不添加public关键字，则它只具有包访问权限，这样它就只能在同一个包内可用。


5.接口也可以包含域，但是这些域隐式地是static和final的。


6.在接口中显示地将方法声明为public的，但即使你不这么做，它们也是public的。因此，当要实现一个接口时，在接口中定义的方法必须被定义为是public的；否则，它们将只能得到默认的包访问权限，这样在方法被继承的过程中，其可访问权限就被降低了，这是Java编译器所不允许的。


7.只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想要将这个方法应用于不在此继承结构中的某个类，那么你就会触霉头了。接口可以在很大程度上放宽这种限制，因此，它使得我们可以编写可复用性更好的代码。


8.接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法设计模式。这与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而工厂对象将生成接口的某个实现的对象。理论上，通过这种方式，我们的代码将完全与接口的实现分离，这就是使得我们可以透明地将某个实现替换为另一个实现。


9.“确定接口是理想选择，因而应该总是选择接口而不是具体的类。”这其实是一种诱惑。当然，对于创建类，几乎在任何时刻，都可以替代为创建一个接口和一个工长。许多人都掉进了这种诱惑的陷阱，只要有可能去创建接口和工厂。这种逻辑看起来好像因为需要使用不同的具体实现，因此总是应该添加这种抽象性。这实际上已经变成了一种草率的设计优化。任何抽象性都应该是应真正的需求而产生的。当必须时，你应该重构接口而不是到处添加额外级别的间接性，并由此带来的额外的复杂性。这种额外的复杂性非常显著，如果你让某人去处理这种复杂性，只是因为你意识到由于以防万一而添加了新接口，而没有其他更有说服力的原因，那么好吧，如果我碰上了这种事，那么就会质疑此人所作的所有设计了。恰当的原则应该是优化选择类而不是接口。从类开始，如果接口的必需性变得非常明确，那么就进行重构。接口时一种重要的工具，但是它们容易被滥用。


10.因为你放入接口中的任何域都自动是static和final的，所以接口就称为了一种很便捷的用来创建常量组的工具。在Java SE5之前，这是产生与C或C++中enum具有相同效果的类型的唯一途径。Java中标识具有常量初始化值得static final时，会使用大写字母的风格（在一个标识符中国用下划线来分隔多个单词）。接口中的域自动是public的，所以没有显式地指明这一点。

-------------------------------------------------------------------------------------------------------------------------------
四.final

1.许多编译语言都有某种方法，来向编译器告知一块数据是恒定不变的。有时数据的恒定不变是很有用的，比如：
(1)一个永不改变的编译时常量。（注:我们不能因为某些数据是final的就认为在编译时可以知道它的值。在运行时使用随机生成的数值来初始化可以证明这一点。）
(2)一个在运行时被初始化的值，而你不希望它被改变。
对于编译期常量这种情况，编译器可以将该变量值代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式，这减轻了一些运行时的负担。在Java中，这类常量必须是基本数据类型，并且以关键字final表示。在对这个常量进行定义的时候，必须对其进行赋值。


2.一个既是static又是final的域只占据一段不能改变的存储空间。当对对象引用而不是基本类型运用final时，其含义会有一点令人迷惑。对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径（但可以自己编写类以取得使对象恒定不变的效果）。这一限制同样适用数组，它也是对象。


3.带有恒定初始值（即，编译器常量）的final static基本类型全用大写字母命名，并且字与字之间用下划线隔开（延续自C）。


4.Java允许生成“空白final”，所谓空白final是指被声明为final但又未给定初始值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。但是，空白final在关键字final的使用上提供了更大的灵活性，为此，一个类中final域就可以做到根据对象而有所不同，却又保持其恒定不变的特性。必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。


5.Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。这一特性主要用来向匿名内部类传递数据。


6.final方法：
(1)使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义。这是出于设计的考虑：想要确保在继承中使用方法行为保持不变，并且不会被覆盖。过去建议使用final方法的第二个原因是效率。在Java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来替代方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码就会膨胀，因此可能看不到内嵌带来的任何性能提高，因此，所带来的性能提高会因为花费于方法内的时间量而被缩减。在最近的Java版本中，虚拟机（特别是hospot技术）可以探测到这些情况，并优化去掉这些效率反而降低的额外的内嵌调用，因此不再需要使用final方法来进行优化了。事实上，这种做法正在逐渐地受到劝阻。在使用Java SE5/6时，应该让编译器和JVM去处理效率问题，只有在想要明确禁止覆盖时，才将方法设置为final的。
(2)将方法声明为final，那就说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。另外有一种被称为inline的机制，它会使你在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，所以你要慎用final进行方法定义。


7.final和private关键字：类中所有的private方法都隐式地指定为是final的。由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰词，但这并不会给该方法增加任何额外的意义。


8.final类：(1)当将某个类的整体定义为final时（通过将关键字final置于它的定义之前），就表明了你不打算继承该类，而且也不允许别人这样做。换句话说，出于某种考虑，你对该类的设计永不需要做任何变动，或者出于安全的考虑，你不希望它有子类。final类的域可以根据个人的意愿选择为是或不是final。不论类是否被定义为final，相同的规则都适用于定义为final的域。然而，由于final类禁止继承，所以final类中所有的方法都隐式指定为是final的，因为无法覆盖它们。在final类中可以给方法添加final修饰词，但这不会添加任何意义。
(2)当你将final用于类身上时，你就需要仔细考虑，因为一个final类是无法被任何人继承的，那也就意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。对于final类中的成员，你可以定义其为final，也可以不是final。而对于方法，由于所属类为final的关系，自然也就成了final型的。你也可以明确的给final类中的方法加上一个final，但这显然没有意义。

-------------------------------------------------------------------------------------------------------------------------------

五.static

1.static变量在装载时已被初始化，而不是每次创建新对象时都初始化。


2.构造器与main方法都是static方法，尽管static关键字并没有显式地写出来。因此更准确地讲，类是在其任何static成员被访问时加载的。


3.在许多传统语言中，程序时作为启动过程的一部分立刻被加载的。然后是初始化，紧接在程序开始运行。这些语言的初始化过程必须小心控制，以确保定义为static的东西，其初始化顺序
不会造成麻烦。例如C++中，如果某个static期望另一个static在被初始化之前就能有效地使用它，那么就会出现问题。Java就不会出现这个问题，因为它采用了一种不同的加载方式。加载时众多变得更加容易地动作之一，因为Java中的所有事物都是对象。请记住，每个类的编译代码都存于它自己的独立的文件中。该文件只在需要使用程序代码时才会被加载。一般来说，可以说：“类的代码在初次使用时才加载。”这通常是指加载发生于创建类的第一个对象之时，但是当访问static域或static方法时，也会发生加载。初次使用之处也是static初始化发生之处。所有的static对象和static代码段都会在加载时依程序中的顺序（即，定义类时的书写顺序）而依次初始化。当然，定义为static的东西只会被初始化一次。