# 11.持有对象

1.java容器类都可以自动地调整自己的尺寸。

2.预定性泛型使用非常方便，通过使用泛型，就可以在编译器防止将错误类型的对象放置到容器中。

2.1COLLECTION线性表
Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│ └Stack
└Set
Map
├Hashtable
├HashMap
└WeakHashMap


3.容器类
(1)collection。一个独立元素的序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存元素，而Set不能有重复元素。Queue按照排队规则来圈定对象产生的顺序（通常与他们被插入的顺序相同）。
(2)map。一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，因此在某种意义上讲，它将数字与对象关联在了一起。映射表允许我们使用另一个对象来查找某个对象，它也被称为“关联数组”，因为它将某些对象与另外一些对象关联在了一起；或者被称为“字典”，因为你可以使用键对象来查找值对象，就像在字典中使用单词来定义一样。Map是强大的编程工具。
尽管并非总是这样，但是在理想情况下，你编写的大部分代码都是在与这些接口打交道，并且你唯一需要指定所使用的精确类型的地方就是在创建的时候。因此，你创建一个具体的对象，将其转型为对应的接口，然后再其余的代码中都使用这个接口。这种方式并发总能奏效，因为某些类具有额外的功能，例如，LinkedList具有在List接口中未包含的额外方法，而TreeMap也具有在Map接口中未包含的方法。如果你需要使用这些方法，就不能将它们向上转型为更通用的接口。

4.Collection的构造器可以接受另一个Collection，用它来将自身初始化，因此你可以使用Array.List()来为这个构造器产生输入。但是，Collection.addAll()方法允许起来要快得多，而且构建一个不包含元素的Collection，然后调用Collections.addAll()这种方式很方便，因此它是首选方式。

5.你也可以直接使用Arrays.asList()的输出，将其当作List,但是在这种情况下，其底层表示的是数组，因此不能调整尺寸。如果你试图用add()或delete()方法在这种列表中添加或删除元素，就有可能会引发去改变数组尺寸的尝试，因此你将在运行时获得“unsupported operating”错误。

6.Collection在每个槽中只能保存一个元素。此类容器包括：List，它以特定的顺序保存一组元素；Set,元素不能重复;Queue，只允许在容器的一“端”插入对象，并从另外一“端”移除对象（对于本例来说，这只是另外一种观察序列的方式，因此并没有展示它）。Map在每个槽内保存了两个对象，即键和与之相关联的值。

7.list,可以使用contains()方法来确定某个对象是否在列表中。如果你想移除一个对象，则可以将这个对象的引用传递给remove()方法。同样，如果你有一个对象的引用，则可以使用indexOf()来发现该对象在List中所处位置的索引编号。


8.迭代器（也是一种设计模式）的概念可以用于达成此目的。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器通常被称为轻量级对象；创建它的代价小。因此，经常可以见到对迭代器有些奇怪的限制；例如，JAVA的Iterator只能单向移动，这个Iterator只能用来：
(1)使用方法iterator()要求容器返回一个Iterator()。Iterator将准备好返回序列的第一个元素。
(2)使用next()获得序列中的下一个元素。
(3)使用hasNext()检查序列中是否还有元素。
(4)使用remove()将迭代器新近返回的元素删除。

8.1如果你只是向前遍历List，并不打算修改List对象本身，那么你可以看到foreach语法会显得更加简洁。

8.2迭代器关注数据类型，不关注容器（序列）类型。

8.3Iterator能够将遍历序列的操作与序列底层的结构分类。正由于此，我们有时会说：迭代器统一了对容器的访问方式。

9.foreach是迭代器实现的一个方法。能使用foreach访问的对象，一定是实现了迭代器的接口。

10.迭代器能够将遍历序列的操作与序列底层的结构分离。

11.ListIterator是一个更加强大的Iterator的子类型，它只能用于各种List类的访问。尽管Iterator只能向前移动，但是ListIterator可以双向移动。它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。你可以通过调用ListIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listiterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。

12.rrayList
ArrayList其实是包装了一个数组 Object[]，当实例化一个ArrayList时，一个数组也被实例化，当向ArrayList中添加对象是，数组的大小也相应的改变。这样就带来以下有缺点：
快速随即访问 你可以随即访问每个元素而不用考虑性能问题，通过调用get(i)方法来访问下标为i的数组元素。
向其中添加对象速度慢 当你创建数组是并不能确定其容量，所以当改变这个数组时就必须在内存中做很多事情。
操作其中对象的速度慢 当你要想数组中任意两个元素中间添加对象时，数组需要移动所有后面的对象。
数据结构：顺序存储

13.LinkedList
LinkedList是通过节点直接彼此连接来实现的。每一个节点都包含前一个节点的引用，后一个节点的引用和节点存储的值。当一个新节点插入时，只需要修改其中保持先后关系的节点的引用即可，当删除记录时也一样。这样就带来以下有缺点：
操作其中对象的速度快 只需要改变连接，新的节点可以在内存中的任何地方
不能随即访问 虽然存在get()方法，但是这个方法是通过遍历接点来定位的所以速度慢。
数据结构:链式存储


14.Set不报存重复的元素（至于如何判断元素相同则较为复杂，稍后便会看到）。如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复现象。Set中最常被使用的是测试归属性，你可以很容易地询问某个对象是否在某个Set中。正因如此，查找就称为了Set中最重要的操作，因此你通常都会选择一个HashSet的实现，它转码对快速查找进行了优化。


15.Queue
队列是一个电信的先进先出（FIFO）的容器。即从容器的一段放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的。队列常被当作一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中特别重要，因为他们可以安全的将对象从一个任务传输给另一个任务。

