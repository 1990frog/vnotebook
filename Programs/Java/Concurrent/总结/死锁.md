[TOC]

# 死锁的4个必要条件（缺一不可）
+ 互斥条件
+ 请求与保持条件
+ 不剥夺条件
+ 循环等待条件

# 什么是死锁
互不想让：当两个（或更多）线程（或进程）互相持有对方所需要的资源，又不主动释放，导致所有人都无法相继前进，导致程序陷入无尽的阻塞，这就是死锁。

![](_v_images/20191104214641623_1656924229.png)

如果多个线程之间的依赖关系是环形，存在环路的锁的依赖关系，那么也可能会发生死锁。

![](_v_images/20191104214849212_657694985.png)

# 死锁的影响
死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力
数据库中：检查并放弃事物（类似第一个事物放弃，后面执行之后再接着执行第一个事物）
JVM中：无法自动处理（但可以检测）

# 几率不高但危害大
不一定发生，但是遵守“墨菲定律”
一旦发生，多是高并发场景，影响用户多
整个系统崩溃、子系统崩溃、性能降低
压力测试无法找出所有潜在的死锁

# 发生死锁的例子
实际生产中的例子：多个人转账

注意看退出信号：Process finished with exit code 130(interrupted by signal 2:SIGINT)，是不正常退出的信号，对比正常结束的程序的结束信号是0。

# 如何定位死锁
+ jstack
+ ThreadMXBean

# 修复死锁的策略

# 活锁

# 饥饿