# Synchronized的作用
同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。

一句话说出Synchronized的作用：
能保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果

# Synchronized的地位
+ Synchronizde是Java的关键字，被Java语言原生支持
+ 是最基本的互斥同步手段
+ 是并发编程中的元老级角色，是并发编程的必学内容

# 不使用并发手段会有什么后果？
例子：i++
原因：
count++，它看上去只是一个操作，实际上包含了三个动作：
1.读count
2.将count加1
3.将count的值写入到内存中

# Synchronized的两个用法
对象锁：
包括方发锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）
类锁：
指synchronized修饰静态的方法或指定锁为Class对象

![](_v_images/20191026154123446_824375716.png)

# 类锁
概念（重要） ：Java类可能有很多个对象，但只有一个Class对象
形式1：synchronized加在static方法上
形式2：synchronized（*.class）代码块

只有一个Class对象：Java类可能会有很多个对象，但是只有1个Class对象。
本质：所以所谓的类锁，不过是Class对象的锁而已。

# 多线程访问同步方法的7种情况
1. 两个线程同时访问一个对象的同步方法（同一把锁）
2. 两个线程访问的是两个对象的同步方法（两把不同的锁）
3. 两个线程访问的是synchronized的静态方法（同一把锁：类锁）
4. 同时访问同步方法与非同步方法（非同步方法不受到影响）
5. 访问同一个对象的不同的普通同步方法（同一把锁，串行）
6. 同时访问静态synchronized和非静态synchronized方法（两把锁，一把对象锁、一把类锁）
7. 方法抛出异常后，会释放锁（Lock不会释放锁，synchronized会）

# 7种情况总结：3点核心思想
1. 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1、5种情况）；
2. 每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把类锁（对象第2、3、4、6种情况）；
3. 无论方法是正常执行完毕或者方法抛出异常，都会释放锁（对应第7种）

在synchronized方法中调用非synchronized方法，是线程安全的吗？
不是，非synchronized方法，可以被多个线程同时访问，所以不是线程安全的

# synchronized性质
1. 可重入
2. 不可中断

什么是可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁