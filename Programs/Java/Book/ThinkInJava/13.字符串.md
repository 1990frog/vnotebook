# 13.字符串

.String对象时不可变的。查看JDK文档你就会发现，String类中每一个看起来会修改String值得方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。

2.对于一个方法而言，参数是为了该方法提供信息的，而不是想让该方法改变自己的。在阅读这段代码时，读者自然就会有这样的感觉。这一点很重要，正是有了这种保障，才使得代码易于编写与阅读。

3.String对象是不可变的，你可以给一个String都系加任意多的别名。因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值，因此，也就不会对其他的引用有什么影响。

4.C语言中的printf()并不像Java那样连接字符串，它使用一个简单的格式化字符串，加上要插入其中的值，然后将其格式化输出。printf()并不使用重载的“+”操作符(C没有重载)来连接引号内的字符串或字符串变量，而是使用特殊的占位符来表示数据将来的位置。而且它还将插入格式化字符串的参数，以逗号分隔，排成一行。例如printf("Row 1:[%d %f]\n",x,y);这一行代码在运行的时候，首先将x的值插入%d的位置，然后将y的值插入到%f的位置。这些占位符称作格式修饰符，它们不但说明了插入数据的位置，同时还说明了插入什么类型的变量，以及如何对其格式化。在这个例子中，%d表示x是一个整数，%f表示y是一个浮点数（float或者double）。

5.格式化说明符：在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的格式修饰符。以下是其抽象的语法：
%[argument_index$][flags][width][.precision]conversion
%[index$][标识][最小宽度]转换方式
最常见的应用的控制一个域的最小尺寸，这可以通过指定width来实现。Formatter对象通过在必要时添加空格，来确保一个域至少达到某个长度。在默认的情况下，数据是右对齐，不过可以通过使用“-”标志来改变对齐方向。与width相对的是precision，它用来指明最大尺寸。width可以应用于各种类型的数据转换，并且其行为方式都一样。precision则不然，不是所有类型的数据都能使用precision，而且，应用于不同的数据转换时，precision的意义也不同。在将precision应用于String时，它表示打印String时输出字符的最大数量。而在将precision应用于浮点数时，它表示小数部分要显示出来的位数（默认是6位小数），如果小数位数过多则舍入，太少则在尾部补零。由于整数没有小数部分，所以precision无法应用于整数，如果小数位数过多则舍入，太少则在尾部补零。由于整数没有小数部分，所以precision无法应用于整数，如果你对整数应用precision，则会触发异常。


6.d:整数型(十进制),c:Unicode字符,b:Boolean值,s:String,f:浮点型(十进制),e:浮点型(科学计数),x:整数(十六进制),h:散列码(十六进制),%:字符“%”。

7.Java SE5也参考了C中sprintf()方法，以生成格式化的String对象。String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但返回一个String对象。当你只需使用format()方法一次的时候，String.format()用起来很方便。其实在String.format()内部，它也是创建一个Formatter对象，然后将你传人的参数转给该Formatter。不过，与其自己做这些事情，不如使用便捷的String.format()方法，何况这样的代码更清晰易读。


8.Scanner的构造器可以接受任何类型的输入对象，包括File对象、InputStream、String或者像此例中的Readable对象。Readable是Java SE5中新加入的一个接口，表示“具有read()方法的某种东西”。前一个例子中的BufferedReader也归于这一类。有了Scanner，所有的输入、分词以及翻译的操作都隐藏在不同类型的next方法中。普通的next()方法返回下一个String。所有的基本类型（除char之外）都有对象的next方法，包括BigDecimal和BigInteger。所有的next方法，只有在找到一个完整的分词之后才会返回。Scanner还有相应的hasNext方法，用以判断下一个输入分词是否所需的类型。



