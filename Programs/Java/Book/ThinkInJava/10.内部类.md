# 10.内部类

1.可以将一个类的定义放在另一个类的定义内部，这就是内部类。内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而必须要了解，内部类与组合是完全不同的概念，这一点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信；而且你用内部类写出的代码更加优雅清晰，尽管并不总是这样。最初，内部类可能看起来有些奇怪，而且要花些时间才能在设计中轻松地使用它们。


2.到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的外围对象(enclosing object)之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。


3.所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指定那个外围类对象的引用。然后，在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。幸运的是，编译器会帮你处理所有的细节，但你现在可以看到：内部类只能在与其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非static类时）。构造内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候这都无需程序员操心。



4.如果你需要生成对外部对象的引用，可以使用外部类的名字后面紧跟圆点和this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并接受到检查，因此没有任何运行时开销。有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用,这是需要使用.new语法。要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。这也解决了内部类名字作用域的问题，因此你不比声明（实际上你不能声明）。

5.在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。但是，你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。



6.当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。


7.到目前为止，读者所看到的只是内部类的典型用途。通常，如果所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单并且容易理解。然而，内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。这么做有两个理由：
(1)如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。
(2)你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可
用的。


8.在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类。


9.匿名类例：public A a() {return new A() {private int i = 11;public int value() { return i; }};}这种奇怪的语法指的是：“创建一个继承自A的匿名类对象。”通过new表达式返回的引用被自动向上转型为对A的引用。上述匿名类内部类的语法是下述形式的简化形式：public class{ class A implements B{private int i = 11; public int value() { return i; }  } public B b() { return new A(); }}

10.在匿名内部类尾号的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。


11.如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。如果只是简单地给一个字段赋值，那么上述方法就是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类构建一个构造器的效果。在这种情况，不要求变量i一定是final的。因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。


11.tij201不明白












12.对于匿名类而言，实例初始化的实际效果就是构造器。当然它收到了限制——你不能重载实例初始化方法，所以你仅有一个这样的构造器。

13.匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。



14.嵌套类：如果不需要内部类对象与其外围对象之间有联系，那么可以将内部类声明为static。这通常称为嵌套类。想要理解static应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外围类的对象。然而，当内部类是static的时，就不是这样了。嵌套类意味着：
(1)要创建嵌套类的对象，并不需要其外围类的对象。
(2)不能从嵌套类的对象中访问非静态的外围类对象。
嵌套类与普通的内部类还有一个区别。普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以包含所有这些东西。在一个普通的（非static）内部类中，通过一个特殊的this引用可以链接到其外围类对象。嵌套类就没有这个特殊的this引用，这使得它类似于一个static方法。



15.正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。你放到接口中的任何类都自动地是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违法接口的规则。你甚至可以在内部类中实现其外围接口。如果你想要创建某些公告代码，使得它们可以被某个接口的所有不同实现所公用，那么使用接口内部的嵌套类会显得很方便。


16.至此，我们已经看到了许多描述内部类的语法和语义，但是这并不能回答“为什么需要内部类”这个问题。那么，Sun公司为什么会如此费心地增加这项基本的语言特性呢？一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象。所以可以认为
内部类的代码操作创建它的外围类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。内部类必须要回答的一个问题是：如果只是需要一个对接口的引用，为什么不通过外围类实现那个接口呢？答案是：“如果这能够满足需求，那么就应该这样做。”那么内部类实现一个接口与外围类实现这个接口有什么区别呢？答案是：后者不是总能享用到接口到来的方便，有时需要用到接口的实现。所以，使用内部类最吸引人的原因是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的，可以继承多个具体的或抽象的类的能力，一下设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽象类）。


17.如果不需要解决“多重继承”的问题，那么自然可以用别的方式编码，而不需要使用内部类。但如果使用内部类，还可以获得其他一些特性：
(1)内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
(2)在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
(3)创建内部类对象的时刻并不依赖于外围类的创建。
(4)内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。

18.如果Sequence.java不使用内部类，就必须声明“Sequence是一个Selector”，对于某个特定的Sequence只能有一个Selector。然而使用内部类很容易就拥有另一个方法reverseSelector()，用它来生成一个反方向遍历序列的Selector。只有内部类才有这种灵活性。

19.闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。

20.Java最引人争议的问题之一就是，人们认为Java应该包含某种类似指针的机制，以允许回调(callback)。通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。稍后将会看到这是一个非常有用的概念。如果回调是通过指针实现的，那么就只能寄希望于程序员不会误用该指针。然而，读者应该已经了解到，Java更小心仔细，所以没有在语言中包含指针。通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。


21.回调的价值在于它的灵活性，可以在运行时动态地决定需要调用什么方法。


22.应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题（这是设计模式中模板方法的一个例子）。模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。这要用来响应事件系统被称作驱动系统。要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。接下来的问题就是，对于要控制什么，控制框架并不含任何具体的信息。那些信息是在实现算法的action()部分时，通过继承来提供的。

23.内部类允许：
(1)控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表现解决问题所必须的各种不同的action()。
(2)内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。

24.可以在代码块里创建内部类，典型的方式是在一个方法体的里面创建。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。


25.局部内部类的名字在方法外是不可见的，那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。所有使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部类的对象。

26.由于每个类都会产生一个.class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“meta-class”，叫做Class对象），你可能猜到了，内部类也必须生成一个.class文件以包含它们的Class对象信息。这类文件的命名有严格的规则：外围类的名字，加上“$”，再加上内部类的名字。例如：HellowWorldClass$a.class。如果内部类是匿名的，编译器会简单地产生一个数字作为其标识符。如果内部类是嵌套在别的内部类之中，只需直接将它们的名字加在其外围类标识符与“$”的后面。虽然这种命名格式简单而直接，但它还是很健壮的，足以应对绝大多数情况。因为这是Java的标准命名方式，所以产生的文件自动都是平台无关的。



1.如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：OuterClassName.InnerClassName。



局部内部类 匿名类

局部内部类 的类在方法内，外部不可访问。
匿名类 的类是实现接口或基类向上转型，可使用基类。


