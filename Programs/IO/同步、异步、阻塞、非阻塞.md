[TOC]

# 常规的误区
假设有一个展示用户详情的需求，分两步，先调用一个HTTP接口拿到详情数据，然后使用适合的视图展示详情数据。
如果网速很慢，代码发起一个HTTP请求后，就卡住不动了，直到十几秒后才拿到HTTP响应，然后继续往下执行。
这个时候你问别人，刚刚代码发起的这个请求是不是一个同步请求，对方一定回答是<font color="red">（因为服务端主动返回了响应）</font>。这是对的，它确实是。
但你要问它为什么是呢？对方一定是这样回答的，“因为发起请求后，代码就卡住不动了<font color="red">(其实这是阻塞)</font>，直到拿到响应后才可以继续往下执行”。
我相信很多人也都是这样认为的，其实这是不对的，是把因果关系搞反了：
<font color="red">不是因为代码卡住不动了才叫同步请求，而是因为它是同步请求所以代码才卡住不动了。</font>

至于为什么能卡住不动，这是由操作系统和CPU决定的：
因为内核空间里的对应函数会卡住不动，造成用户空间发起的系统调用卡住不动，继而使程序里的用户代码卡住不动了<font color="red">（这不应该是阻塞吗？）</font>。
因此卡住不动了只是同步请求的一个副作用，并不能用它来定义同步请求，那该如何定义呢？

# 同步和异步
## 同步（synchronized）
所谓同步，指的是协同步调。既然叫协同，所以至少要有2个以上的事物存在。协同的结果就是：
多个事物不能同时进行，必须一个一个的来，上一个事物结束后，下一个事物才开始。
那当一个事物正在进行时，其它事物都在干嘛呢？
严格来讲这个并没有要求，但一般都是处于一种“等待”的状态，因为通常后面事物的正常进行都需要依赖前面事物的结果或前面事物正在使用的资源。
<font color="red">因此，可以认为，同步更希望关注的是从宏观整体来看，多个事物是一种逐个逐个的串行化关系，绝对不会出现交叉的情况。</font>
所以，自然也不太会去关注某个瞬间某个具体事物是处于一个什么状态。

把这个理论应用的出神入化的非“排队”莫属。凡是在资源少需求多的场景下都会用到排队。比如排队买火车票这件事：
其实售票大厅更在意的是旅客一个一个的到窗口去买票，因为一次只能卖一张票。
即使大家一窝蜂的都围上去，还是一次只能卖一张票，何必呢？挤在一起又不安全。
只是有些人素质太差，非要往上挤，售票大厅迫不得已，采用排队这种形式来达到自己的目的，即一个一个的买票。
至于每个旅客排队时的状态，是看手机呀还是说话呀，根本不用去在意。
除了这种由于资源导致的同步外，还存在一种由于逻辑上的先后顺序导致的同步。
比如，先更新代码，然后再编译，接着再打包。这些操作由于后一步要使用上一步的结果，所以只能按照这种顺序一个一个的执行。

<font color="red">
关于同步还需知道两个小的点：
一是范围，并不需要在全局范围内都去同步，只需要在某些关键的点执行同步即可。
比如食堂只有一个卖饭窗口，肯定是同步的，一个人买完，下一个人再买。但吃饭的时候也是一个人吃完，下一个人才开始吃吗？当然不是啦。
二是粒度，并不是只有大粒度的事物才有同步，小粒度的事物也有同步。
只不过小粒度的事物同步通常是天然支持的，而大粒度的事物同步往往需要手工处理。
比如两个线程的同步就需要手工处理，但一个线程里的两个语句天然就是同步的。</font>

## 异步
所谓异步，就是步调各异。既然是各异，那就是都不相同。所以结果就是：
多个事物可以你进行你的、我进行我的，谁都不用管谁，所有的事物都在同时进行中。

## 总结
一言以蔽之，同步就是多个事物不能同时开工，异步就是多个事物可以同时开工。  
注：一定要去体会“多个事物”，多个线程是多个事物，多个方法是多个事物，多个语句是多个事物，多个CPU指令是多个事物。等等等等。

# 阻塞和非阻塞
+ 所谓阻塞，指的是阻碍堵塞。它的本意可以理解为由于遇到了障碍而造成的动弹不得。
+ 所谓非阻塞，自然是和阻塞相对，可以理解为由于没有遇到障碍而继续畅通无阻。

对这两个词最好的诠释就是，当今中国一大交通难题，堵车：
汽车可以正常通行时，就是非阻塞。一旦堵上了，全部趴窝，一动不动，就是阻塞。
因此阻塞关注的是不能动，非阻塞关注的是可以动。
不能动的结果就是只能等待，可以动的结果就是继续前行。
因此和阻塞搭配的词一定是等待，和非阻塞搭配的词一定是进行。
<font color="red">回到程序里，阻塞同样意味着停下来等待，非阻塞表明可以继续向下执行。</font>

## 阻塞和等待
等待只是阻塞的一个副作用而已，表明随着时间的流逝，没有任何有意义的事物发生或进行。
阻塞的真正含义是你关心的事物由于某些原因无法继续进行，因此让你等待。但没必要干等，你可以做一些其它无关的事物，因为这并不影响你对相关事物的等待。
在堵车时，你可以干等。也可以玩手机、和别人聊天，或者打牌、甚至先去吃饭都行。因为这些事物并不影响你对堵车的等待。不过你的车必须呆在原地。
在计算机里，是没有人这么灵活的，一般在阻塞时，选在干等，因为这最容易实现，只需要挂起线程，让出CPU即可。在条件满足时，会重新调度该线程。

## 两两组合
+ 所谓同步/异步，关注的是能不能同时开工。
+ 所谓阻塞/非阻塞，关注的是能不能动。

### 通过推理进行组合：
+ 同步阻塞，不能同时开工，也不能动。只有一条小道，一次只能过一辆车，可悲的是还TMD的堵上了。
+ 同步非阻塞，不能同时开工，但可以动。只有一条小道，一次只能过一辆车，幸运的是可以正常通行。
+ 异步阻塞，可以同时开工，但不可以动。有多条路，每条路都可以跑车，可气的是全都TMD的堵上了。
+ 异步非阻塞，可以工时开工，也可以动。有多条路，每条路都可以跑车，很爽的是全都可以正常通行。
是不是很容易理解啊。其实它们的关注点是不同的，只要搞明白了这点，组合起来也不是事儿。

### 回到程序里，把它们和线程关联起来：
同步阻塞，相当于一个线程在等待。
同步非阻塞，相当于一个线程在正常运行。
异步阻塞，相当于多个线程都在等待。
异步非阻塞，相当于多个线程都在正常运行。

# I/O
IO指的就是读入/写出数据的过程，和等待读入/写出数据的过程。一旦拿到数据后就变成了数据操作了，就不是IO了。
拿网络IO来说，等待的过程就是数据从网络到网卡再到内核空间。读写的过程就是内核空间和用户空间的相互拷贝。
所以IO就包括两个过程，一个是等待数据的过程，一个是读写（拷贝）数据的过程。而且还要明白，一定不能包括操作数据的过程。

## 阻塞IO和非阻塞IO
应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。按照这样子来理解，只要数据没有到达用户空间，用户线程就操作不了。
如果此时用户线程已经参与，那它一定会被阻塞在IO上。这就是常说的阻塞IO。用户线程被阻塞在等待数据上或拷贝数据上。
非阻塞IO就是用户线程不参与以上两个过程，即数据已经拷贝到用户空间后，才去通知用户线程，一上来就可以直接操作数据了。
用户线程没有因为IO的事情出现阻塞，这就是常说的非阻塞IO。

## 同步IO和同步阻塞IO
按照上文中对同步的理解，同步IO是指发起IO请求后，必须拿到IO的数据才可以继续执行。

按照程序的表现形式又分为两种：

+ 在等待数据的过程中，和拷贝数据的过程中，线程都在阻塞，这就是同步阻塞IO。
+ 在等待数据的过程中，线程采用死循环式轮询，在拷贝数据的过程中，线程在阻塞，这其实还是同步阻塞IO。

网上很多文章把第二种归为同步非阻塞IO，这肯定是错误的，它一定是阻塞IO，因为拷贝数据的过程，线程是阻塞的。

<font color="red">严格来讲，在IO的概念上，同步和非阻塞是不可能搭配的，因为它们是一对相悖的概念。</font>

<font color="red">JAVA的NIO明明就是同步非阻塞IO啊？</font>

+ 同步IO意味着必须拿到IO的数据，才可以继续执行。因为后续操作依赖IO数据，所以它必须是阻塞的。
+ 非阻塞IO意味着发起IO请求后，可以继续往下执行。说明后续执行不依赖于IO数据，所以它肯定不是同步的。

因此，在IO上，同步和非阻塞是互斥的，所以不存在同步非阻塞IO。但同步非阻塞是存在的，那不叫IO，叫操作数据了。

所以，同步IO一定是阻塞IO，同步IO也就是同步阻塞IO。

## 异步IO和异步阻塞/非阻塞IO
按照上文中对异步的理解，异步IO是指发起IO请求后，不用拿到IO的数据就可以继续执行。用户线程的继续执行，和操作系统准备IO数据的过程是同时进行的，因此才叫做异步IO。

按照IO数据的两个过程，又可以分为两种：

+ 在等待数据的过程中，用户线程继续执行，在拷贝数据的过程中，线程在阻塞，这就是异步阻塞IO。
+ 在等待数据的过程中，和拷贝数据的过程中，用户线程都在继续执行，这就是异步非阻塞IO。

第一种情况是，用户线程没有参与数据等待的过程，所以它是异步的。但用户线程参与了数据拷贝的过程，所以它又是阻塞的。合起来就是异步阻塞IO。

第二种情况是，用户线程既没有参与等待过程也没有参与拷贝过程，所以它是异步的。当它接到通知时，数据已经准备好了，它没有因为IO数据而阻塞过，所以它又是非阻塞的。合起来就是异步非阻塞IO。

PS：聪明的你或许发现了我没有提多路复用IO，因为它值得专门撰文一篇。

（END）

---

先来个例子理解一下概念，以银行取款为例：

同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。

异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。

阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。

非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。



Java对BIO、NIO、AIO的支持：

Java BIO (blocking I/O)： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

Java NIO (non-blocking I/O)： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

Java AIO(NIO.2) (Asynchronous I/O) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，



BIO、NIO、AIO适用场景分析:

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

---

“阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。
1.同步与异步
同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如Node.js

举个通俗的例子：
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

2. 阻塞与非阻塞
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。



如果是关心阻塞 IO/ 异步 IO, 参考 Unix Network Programming View Book



--

还是2014年写的以解释概念为主，主要是同步异步 阻塞和非阻塞会被用在不同层面上，可能会有不准确的地方，并没有针对 阻塞 IO/ 异步 IO 等进行讨论，大家可以后续看看这两个回答：

[怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473/answer/14413599)

[怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473/answer/241673170)