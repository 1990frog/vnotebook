[TOC]

性能好，查询快，实时展示结果
非t+1

# ELK
+ Kibana：数据探索与可视化分析
+ Elasticsearch：数据存储、查询与分析
+ Logstash、Beats：数据搜集与处理（ETL：Extract Transform Load）

# 常见术语
+ 文档Document：用户存储在es中的数据文档
+ 索引Index：由具有相同字段的文档列表组成
+ 节点Node：一个Elasticsearch的运行实例，是集群的构成单元
+ 集群Cluster：由一个或多个节点组成，对外提供服务

# 与关系性数据库的类比

| RDBMS(MySQL) | Elasticsearch |
| ------------ | ------------ |
| Table        | Index(Type)   |
| Row          | Doucment      |
| Column       | Field         |
| Schema       | Mapping       |
| SQL          | DSL           |

# index
Index：索引是文档的容器，是一类文档的结合
+ index体现了逻辑空间的概念： 每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型
+ Shard体现了物理空间的概念：索引中的数据分散在Shard上

索引的Mapping与Settings
+ Mapping定义文档字段的类型
+ Setting定义不同的数据分布

索引中存储具有相同结构的文档（Document）
+ 每个索引都有自己的mapping定义，用于定义字段名和类型

一个集群可以有多个索引，比如：
nginx日志存储的时候可以按照日期每天生成一个索引来存储
+ nginx-log-2017-01-01
+ nginx-log-2017-01-02

# Document
+ Elasticsearch是面向文档的，文档是所有可搜索数据的最小单位
+ 文档会被序列化JSON格式，保存在Elasticsearch中
+ JSON对象由字段组成,每个字段都有对应的字段类型 (字符串/数值/布尔/日期/二进制/范围类型),每个文档都有一个Unique ID
+ 唯一标识：自行指定ID,或者通过Elasticsearch自动生成

## 常见数据类型
json object，由字段（field）组成，常见数据类型如下：
+ 字符串：text，keyword
+ 数值型：long,integer,short,byte,double,float,half_float,scaled_float
+ 布尔：boolean
+ 二进制：binary
+ 范围类型：integer_range,float_range,long_range,double_range,date_range

## Document MetaData 元数据
+ _index：文档所在的索引名
+ _type：文档所在的类型名
+ _id：文档唯一id
+ _source：文档的原始json数据，可以从这里获取每个字段的内容
+ _all：整合所有字段内容到该字段，默认禁用

# ElasticSearch两种交互方式
+ Curl命令行
+ Kibana DevTools

# elasticsearch启动参数
```
>elasticsearch -Ecluster.routing.allocation.disk.threshld_enabled=galse -Epath.data=data
```

# kibaba控制台路径
kibana：http://127.0.0.1:5601/app/kibana


# Restful api
```
POST /uri 创建
DELETE /uri/xxx 删除
PUT /uri/xxx 更新或创建
GET /uri/xxx 查看
```
POST不用加具体的id，它是作用在一个集合资源之上的（/uri），而PUT操作是作用在一个具体资源之上的（/uri/xxx）。
在ES中，如果不确定document的ID（documents具体含义见下），那么直接POST对应uri（ “POST /website/blog” ），ES可以自己生成不会发生碰撞的UUID；
如果确定document的ID，比如 “PUT /website/blog/123”，那么执行创建或修改（修改时_version版本号提高1）

在幂等性的区别如下：
+ PUT、GET、DELETE是幂等的，由于同一条这样的指令，执行多次结果都一样。比如 PUT /uri/xxx 多次，那么结果和这条指令执行一次效果一样。
+ 而POST是非幂等的，执行多次更改多次服务器状态。比如POST /uri 多次，那么生成多个UUID的document，执行多次效果当然和执行一次不一样了~

# Document API
## 创建文档
### 指定ip
```
PUT /index/{id}
{
    json
}
```
### 自动生成ip
```
POST /index
{
    json
}
```
### 批量创建文档
```
POST _bulk
{"index":{}}
{"delete":{}}

action_type:index,update,create,delete

index与create区别：create操作如果文档存在，则报错
```
## 查询
### 获取指定ip的文档
```
GET /INDEX/{id}
```
### 获取全部文档
```
GET /INDEX/_search

GET /INDEX/_search
{
    "query":{
        查询条件
     }
}
```
### 批量查询
```
GET /_mget
{
    "docs":[
    {},
    {}
    ]
}
```