[TOC]

# 流量控制规则（FLowRule）
|      Field      |                            说明                            |          默认值          |
| -------------- | --------------------------------------------------------- | ----------------------- |
| resource        | 资源名，资源名是限流规则的作用对象	                             |                         |
| count           | 限流阈值	                                                 |                         |
| grade           | 限流阈值类型，QPS 模式（1）或并发线程数模式（0）	                 | QPS 模式                 |
| limitApp        | 流控针对的调用来源	                                         | default，代表不区分调用来源 |
| strategy        | 调用关系限流策略：直接、链路、关联	                             | 根据资源本身（直接）        |
| controlBehavior | 流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流	 | 直接拒绝                 |
| clusterMode     | 是否集群限流	                                            | 否                      |

通过代码定义流量控制规则
理解上面规则的定义之后，我们可以通过调用 FlowRuleManager.loadRules() 方法来用硬编码的方式定义流量控制规则，比如：
```java
private void initFlowQpsRule() {
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule(resourceName);
    // set limit qps to 20
    rule.setCount(20);
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    rule.setLimitApp("default");
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

# 流控规则（流量控制）对应的类FlowRule
流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。

![](_v_images/20200314003632736_2074418010.png)

# 阈值类型
## 并发线程数流量控制
并发线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对太多线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离）。这种隔离方案虽然隔离性比较好，但是代价就是线程数目太多，线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。

Sentinel并发线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程数目，如果超出阈值，新的请求会被立即拒绝，效果类似于信号量隔离。

并发限流不能使用匀速排队策略
## QPS流量控制
当QPS超过某个阈值的时候，则采取措施进行流量控制。流量控制的效果包括以下几种：快速失败、Warm Up、匀速排队。
注意：若使用除了直接拒绝之外的流量控制效果，则调用关系限流策略（strategy）会被忽略。

# 流控模式
## 直接
顾名思义
## 关联
当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。
比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。
如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。
可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，`read_db`和`write_db`这两个资源分别代表数据库读写，我们可以给`read_db`设置限流规则来达到写优先的目的：设置`FlowRule.strategy`为`RuleConstant.RELATE`同时设置`FlowRule.ref_identity`为 `write_db`。这样当写库操作过于频繁时，读数据的请求会被限流。
### 例子
资源名：url1
关联资源：url2
当url2达到阈值就限流url1这个资源
### 针对来源
可以对来源粒化，设置为default不针对来源
## 链路
只记录指定链路上的流量，指定资源由入口资源进来的流量如果达到阈值就开始限流
### 例子
A调用C
B调用C
直接调用B
分别限流
### 入口资源
针对来源是微服务级别的
入口资源是api级别的

# 流控效果
## 快速失败
当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出`FlowException`。
这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。
类似线程池已经达到最大线程数，而且有容量限制的`queue`满了，直接就开始拒绝工作了

相关代码：`com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController`
## 排队等待（流量整形）
匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。
如果使用这种模式，那么阈值类型必须设成qps，不能使用线程，否则无效
这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。
![](_v_images/20200314003713920_388937887.png)
源码：`com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController`
### 例子
适用于应对突发流量的场景
设置单机阈值10，每秒只运行10次请求，再设置超时时间500，超过500s就丢弃这次请求
## Warm Up（预热）
即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮
根据codeFactor（默认3）的值，从`阈值/codeFactor`初始值，经过预热时长，才达到设置的qps阈值

源码：`com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController`
`看看Google guava SmoothRateLimiter.java`

![](_v_images/20200314003657072_1276072412.png)

### 例子
假设单机阈值设置100，预热时长设置10s，那么就会用100/3作为最初的阈值，达到10s之后才会设置100为阈值