[TOC]

![](_v_images/20200323200909734_523683364.png)

# 概览
RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制为事务消息提供了持久化能力；RocketMQ的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。

# 概念
半消息
暂时无法消费的消息。生产者将消息发送到了mq server，但这个消息会被标记为“暂不能投递”状态，先存储起来；消费者不会去消费这条消息

消息回查
网络断开或生产者重启可能导致丢失事务消息的第二次确认。当mq server发现消息长时间处于半消息状态时，将向消息生产者发送请求，询问该消息的最终状态（提交或回滚）

# 事务消息的三种状态
+ commit：提交事务消息，消费者可以消费次消息
+ rollback：回滚事务消息，broker会删除该消息，消费者不能消费
+ unknown：broker需要会查确认该消息的状态

# 流程
1. producer发送半消息给mq
2. mq接受成功发送回执给producer（确认接收到半消息）
3. producer执行本地事务，成功发送commit给mq，失败发送fallback给mq
4. mq收到producer发送的commit或fallback就执行响应的操作，向consumer发送消息，或者退回消息
5. 如果上一步在producer发送确认消息时发生异常，消息发送失败，mq在长时间未收到二次确认就会回查
6. producer检查本地事务状态

# 生产者
第一步与第二步发生异常都会触发回滚，但是第三步发生异常虽然也会触发回滚，但是第二步的消息已经发生出去了
```
@Transactional(rollbackFor = Exception.class)
public void save(){
    // step-1
    db.save();
    // step-2
    mqTemplate.convertAndSend();
    // step-3
    cache();
}
```
# 事务消息
如果步骤4断网了或者重启了，就有可能导致mqserver没有拿到二次确认的结果

# 发送半消息
```java
rocketMQTemplate.sendMessageInTransaction();
```