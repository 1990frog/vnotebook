# 21.并发

一.概要
1.并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。

一.基层部分

1.Runnable:线程可以驱动任务。线程中任务通过Runnable接口实现，在run()方法中来执行任务。如果想执行run()必须将它附着到一个线程上。Runnalbe是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口,在javase5中引入的Callable是一种具有类型参数的泛型，他的类型参数表示的是从方法call()中返回的值，并且必须使ExecutorService.submit()方法调用它。submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。你可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，你可以调用get()方法来获取该结果。你也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞，直至结果准备就绪。你还可以在试图调用get()来获取结果之前，先调用具有超时的get(),或者调用isDone来查看任务是否完成。定义任务可以实现Runnable接口，也可以继承Thread类。

2.Thread构造器只需要一个Runnable对象。调用Thread对象的start()方法为该线程执行必须的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务。Thread.yieId()方法暗示线程调度机制优先级，不保证被启用。线程执行顺序是由线程调度器自动控制的。线程调度机制是非确定性的。

3.后台线程(守护线程，精灵线程):Thread.setDaemon();setDaemon()方法必须在start()之前。后台线程在最后一个非后台线程终止时，后台线程会突然终止。

4.所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。比如，执行main()的就是一个非后台线程。（程序运行就是一个商队，守护线程就是护航舰；非守护线程是商船负责监测）

5.Executor:CachedThreadPoll无限线程数，FixedThreadPoll有限线程数，可以限制线程数量。SingleThreadExecutor 线程数为1，可用于长期存活的任务，如果向其提交了多个任务，那么这些任务将会排队。shutdown()方法调用可以防止新任务被提交给这个Executor,当前线程将会继续运行shutdown()被调用之前提交的所有任务。这个程序将在Executor中的所有的任务完成之后尽快退出。

6.Executor通过调用submit()而不是executor()来启动任务，就可以持有改任务的上下文。submit()将返回一个泛型Future<?>,其中有一个未修饰的参数，因为你永远都不会在其上调用get()—持有这种Future的关键在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务。如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限。因此，cancel()是一种中断由Executor启动的单个线程的方式。使用execute()来启动两个任务，并调用e.shutdownNow()将可以很容易地终止所有事物，而对Future，只有在将中断发送给一个线程，同时不发送给另一个线程时才是必需的。

7.异常不能跨线程传播，所有你必须在本地处理所有在任务内部产生的异常。

8.优先级MAX_PRIORITY,NORM_PRIORITY,MIN_PRIORITY.

9.一个线程可以在第二个线程之上调用join()方法，其效果是等待一段时间知道第二个线程结束才继续执行（A线程通过B的对象调用JOIN()，B执行之后A接着执行。JOIN()必须在Thread类内部使用）。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复(即t.isAlive()返回为假)。对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法。

10.Thread.UncaughtException-Handler接口允许你在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因为捕获的异常而临近死亡时被调用。

11.线程状态：1新建(new)：当线程被创建时，它只会短暂地处于这种状态。此时它已经分配了必须的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。2就绪(Runnable)：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态。3阻塞(Blocked)：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。4死亡(Dead)：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已结束，或不再是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断，你将要看到这一点。


二.共享资源

1.所有对象都自动含有单一的锁(也称为监视器)。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕之后才能被调用。对于前面的方法，如果某个任务对对象调用了f()，对于同一个对象而言，就只能等到f()调用结束并释放了锁之后，其他任务才能调用f()和g()。所以，对于某个特定对象来说，其所有synchronized方法共享同一个锁，这可以被用来防止多个任务同时访问被编码为对象内存。注意，在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就
不能防止其他任务直接访问域，这样就会产生冲突。

2.线程锁（互斥）:基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。通常这是通过在代码前面加上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。因为锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量(mutex)。

3.临界区(synchronized(syncObject){}):有时，你只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出来的代码段被称为临界区，它也使用synchronized关键字建立。这里，synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。这也被称为同步控制块；在进入此段代码前，必须得到syncObject对象的锁。如果其他线程已得到这个锁，那么就得得到锁被释放以后，才能进入临界区。通过使用同步控制块，而不是对整个方法进行同步控制，可以使多个任务访问对象的时间性能得到显著提高。synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this)。在这种方法中，如果获得了synchronized块上的锁，那么该对象其他的synchronized方法和临界区就不能被调用了。因此，如果在this上同步，临界区的效果就会直接缩小在同步范围内。有时必须在另一个对象上同步，但是如果你要这么做，就必须确保所有相关的任务都是在统一对象上同步的。

4.volatile关键字还确保了应用中的可视性。如果你将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看都这个修改。即使是用来本地缓存，情况也确实如此，volatile域会立即被写入到主存中，而读取操作就发生在主存中。在非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。synchronized也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用synchronized关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。当一个域的值依赖于它之前的值时(例如递增一个计数器),volatile就无法工作了。如果某个域的值受到其他域的值得限制，那么volatile也无法工作，例如Range类的lower和upper边界就必须遵循lower<=upper的限制。基本上，如果一个域可能会被多个任务同时访问，或者这些任务中至少有一个是写入任务，那么你就应该将这个域设置为volatile的。如果你将一个域定义为volatile，那么它就会告诉编译器不要执行任何移除读取和写入操作的优化，这些操作的目的是用线程中的局部变量维护对这个域的精确同步。实际上，读取和写入都是直接针对内存的，而却没有被缓存。但是，volatile并不能对递增不是原子性操作这一事实产生影响。

5.在多任务器系统(现在以多核处理器的形式出现，即在单个芯片上有多个CPU)上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。一个任务做出的修改，即使在不中断的意义上将是原子性的，对其他任务也可能是不可视(例如，修改只是暂时性地存储在本地处理器的缓存中)，因此不同的任务对应用的状态有不同的视图。另一方面，同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的。如果没有同步机制，那么修改时可视将无法确定。


6.ThreadLocal 线程本地存储。ThreadLocal对象通常作为静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象内容，其中，get()方法京返回与其线程相关联的对象的副本,而set()会将参数插入到为其线程存储的对象中，并返回存储中原有的对象。防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储，因此，如果你有5个线程都要使用变量x所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。主要是，它们使得你可以将状态与线程关联起来。




三.线程握手

1.调用sleep()的时候锁并没有被释放，调用yield()也属于这种情况，理解这一点很重要。另一方面，当一个任务在方法里遇到了对wait()的调用的时候，线程的执行被挂起，对象上的锁被释放。因为wait()将释放所，这就意味着另一个任务可以获得这个锁，因此在该对象(现在是未锁定的)中的其他synchronized方法可以在wait()期间被调用。这一点至关重要，因为这些其他的方法通常将会产生改变，而这种改变正是使被挂起的任务重新唤醒所感兴趣的变化。因此，当你调用wait()时，就是在声明:我已经刚刚做完能做的所有事情，因此我要在这里等待，但是我希望其他的synchronized操作在条件合适的情况下能够执行。

2.有两种形式的wait()。第一种版本接受毫秒数作为参数，含义与sleep()方法里参数的意思相同，都是指“在此期间暂停”。但是与sleep()不同的是，对于wait()而言：
(1)在wait()期间对象锁是释放的。
(2)可以通过notify()，notifyAll()，或者令时间到期，从wait()中恢复执行。第二种，也是更常用形式的wait()不接受任何参数。这种wait()将无限等待下去，直到线程接收到notify()或者notifyAll()消息。


2.实际上，只能在同步控制方法或同步控制块里调用wait()，notify()和notifyAll()（因为不用操作锁，所以sleep()可以在非同步控制方法里调用）。如果在非同步控制方法里调用这些方法，程序能通过编译，但运行的时候，将得到IlleaglMonitorStateException异常，并伴随着一些含糊的消息，比如“当前线程不是拥有者”。消息的意思是，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须“拥有”(获取)对象的锁。可以让另一个对象执行某种操作以维护其自己的锁。要这么做的话，必须首先得到对象的锁。比如，如果要向对象x发送notifyAll()，那么就必须在能够取得x的锁的同步控制块中这么做：synchronized(x){x.notifyAll();}

3.wait()和notifyAll()方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。在许多情况下，你可以瞄向更高的抽象级别，使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入活移除元素。在java.util.concurrent.BlockingQueue接口中提供了这个队列，这个接口有大量的标准实现。你通常可以使用LinkedBlockingQueue，它是一个无届队列，还可以使用ArrayBlockingQueue，它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。如果消费者任务试图从队列中获取对象，而该队列此时为空，那么这些队列还可以挂起消费者任务，并且当有更多的元素可用时恢复消费者任务。阻塞队列可用解决非常大量的问题，而其方法与wait()和notifyAll()相比，则简单并可靠得多。

4.使用notify()而不是notifyAll()是一种优化。使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此如果你希望使用notify()，就必须保证被唤醒的是恰当的任务。另外为了使用notify()，所有任务必须等待相同的条件，因此如果你有多个任务在等待不同的条件，那么你就不会知道是否唤醒了恰当的任务。如果使用notify()，当条件发生变化时，必须只有一个任务能够从中受益。最后，这些限制对所有可能存在的子类都必须总是起作用的。如果这些规则中有任何一条不满足，那么你就必须使用notifyAll()而不是notify()。

5.使用互斥并允许任务挂起的基本类是Condition，你可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，你可以通过signal()来通知这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务(与使用notifyAll()相比，signalAll()是更安全的方式)。

7.进入阻塞状态：一个任务进入阻塞状态，可能有如下原因：1)通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。2)你通过调用wait()使用现场挂起。3)任务在等待某个输入/输出完成。4)任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。

8.忙等待:忙等待是操作系统中的处理进程同步时遇到的一种问题。即当一个进程位于其临界区内，任何试图进入其临界区的进程都必须在进入代码连续循环。一般来说满足三个条件1.互斥执行2.前进3.有限等待即可解决忙等待。

9.必须用一个检查感兴趣的条件的while循环包围wait()。这很重要，因为：1)你可能有多个任务出于相同的原因在等待同一个锁，而第一个唤醒任务可能会改变这种状态（即使你没有这么做，有人也会通过继承你的类去这么做）。如果属于这种情况，那么这个任务应该被再次挂起，直到其感兴趣的条件发生变化。2)在这个任务从其wait()中被唤醒的状态，有可能会有某个其他的任务已经做出了改变，从而使得这个任务在此时不能执行，或者执行其操作已显得无关紧要。此时应该通过再次调用wait()来将其重新挂起。3)也有可能某些任务出于不同的原因在等待你的对象上的锁（在这种情况下必须使用notifyAll()）。在这种情况下，你需要检查是否已经由正确的原因唤醒，如果不是，就再次调用wait()。因此，其本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回wait()中。惯用的方法就是使用while来编写这种代码。

10.在shutdownNow()被调用时，可以看到PipedReader与普通I/O之间最重要的差异——PipedReader是可中断的。如果你将in.read()调用修改为System.in.read(),那么interrupt()将不能打断read()调用。



四.死锁

1.死锁：一个对象可以有synchronized方法或其他形式的加锁机制来防止别的任务在互斥还没有释放的时候就访问这个对象。任务可以变成阻塞状态，所以就可能出现这种情况：某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，知道这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之家相互等待的连续循环，没有哪个线程能继续。这被称之为死锁。







五.新类
1.CountDownLatch它被用来同步一个或多个任务，强制他们等待由其他任务执行的一组操作完成。你可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()的方法都将阻塞，直至这个计数值到达0。其他任务在结束其工作时，可以在该对象上调用countDown()来减少这个计数值。CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用CyclicBarrier。调用countDown()的任务在产生这个调用时并没有阻塞，只有对await()的调用会被阻塞，直至计数值到达0。CountDownLatch的典型用法是将一个程序分为n个互相独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown()。等待问题被解决的任务在这个锁存器上调用await(),将它们自己拦住，直至锁存器计数结束。

2.CyclicBarrier适用于这样的情况：你希望创建一组任务，它们并行地执行工作，然后再进行下一个步骤之前等待，直至所有任务都完成(看起来有些像join())。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动。这非常像CountDownLatch，只是CountDownLatch是触发一次的事物，而CyclicBarrier可以多次重用。
CyclicBarrier(int parties)创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。
CyclicBarrier(int parties, Runnable barrierAction) 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行


一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。

await() 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。





可以向CyclicBarrier提供一个“栅栏动作”，它是一个Runnable，当计数值到达0时自动执行——这是CyclicBarrier和CountDownLatch之间的另一个区别。这里，栅栏动作是作为匿名内部类创建的，它被提交给了Cyclicbarrier的构造器。

3.DelayQueue<E extends Delayed>这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且Poll()将返回null(正因为这样，你不能将null放置到这种队列中)。

DelayQueue 序列内的任务必须实现Delayed接口，此接口的实现必须定义一个 compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。

a) 关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。
b) 缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。
c) 任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。


DelayQueue
是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。


Delayed
一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。
此接口的实现必须定义一个 compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。


getDelay(TimeUnit unit) 返回与此对象相关的剩余延迟时间，以给定的时间单位表示。
参数：
unit - 时间单位
返回：
剩余延迟时间；零或负值指示延迟时间已经用尽


getDelay判断是否到期
compareTo判断序列中元素到期顺序




int compareTo(T o)比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。
实现类必须确保对于所有的 x 和 y 都存在 sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 的关系。（这意味着如果 y.compareTo(x) 抛出一个异常，则 x.compareTo(y) 也要抛出一个异常。）
实现类还必须确保关系是可传递的：(x.compareTo(y)>0 && y.compareTo(z)>0) 意味着 x.compareTo(z)>0。
最后，实现者必须确保 x.compareTo(y)==0 意味着对于所有的 z，都存在 sgn(x.compareTo(z)) == sgn(y.compareTo(z))。 强烈推荐 (x.compareTo(y)==0) == (x.equals(y)) 这种做法，但并不是 严格要求这样做。一般来说，任何实现 Comparable 接口和违背此条件的类都应该清楚地指出这一事实。推荐如此阐述：“注意：此类具有与 equals 不一致的自然排序。”
在前面的描述中，符号 sgn(expression) 指定 signum 数学函数，该函数根据 expression 的值是负数、零还是正数，分别返回 -1、0 或 1 中的一个值。

参数：
o - 要比较的对象。
返回：
负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。


getDelay()它可以用来告知延迟到期有多长时间，或者延迟在多长时间之前已经到期。这个方法将强制我们去使用TimeUnit类，因为这就是参数类型。这会产生一个非常方便的类，因为你可以很容易地转换单位而无需作任何声明。
在getDelay()中，希望使用的单位作为unit参数传递进来的，你使用它将当前时间与触发时间之间的差转为调用者要求的单位，而无需知道这些单位是什么

当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于等于 0 的值时，将发生到期。即使无法使用 take 或 poll 移除未到期的元素，也不会将这些元素作为正常元素对待。


规则是：当前和其他对象比较，如果compare方法返回负数，那么在队列里面的优先级就比较搞。


4.PriorityBlockingQueue这是一个很基础的优先级队列，它具有可阻塞的读取操作。
使用这个序列需要实现Comparable接口。要求插入可比较的对象。


一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。此类不允许使用 null 元素。依赖自然顺序的优先级队列也不允许插入不可比较的对象（这样做会导致抛出 ClassCastException）。






5.ScheduledThreadPoolExecutor通过schedule()（运行一次任务）或者scheduleAtFixedRate()（每隔规则的时间重复执行任务），你可以将Runnable对象设置为在将来的某个时刻执行。
public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                       long delay,
                                       TimeUnit unit)从接口 ScheduledExecutorService 复制的描述
创建并执行在给定延迟后启用的 ScheduledFuture。

指定者：
接口 ScheduledExecutorService 中的 schedule
参数：
callable - 要执行的功能
delay - 从现在开始延迟执行的时间
unit - 延迟参数的时间单位
返回：
可用于提取结果或取消的 ScheduledFuture









6.Semaphore 正常的锁（来自concurrent.locks或内建的synchronized锁）在任何时刻都只允许一个任务访问一项资源，而计数信号量允许n个任务同时访问这个资源。你还可以将信号量看作是向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象。作为一个示例请考虑对象池的概念，它管理着数量有限的对象，当要使用对象时可以签出它们，而在用户使用完毕时，可以将它们签回。

信号量（英语：Semaphore）又称为号志，它以一个整数变量，提供信号，以确保在并行计算环境中，不同进程在访问共享资源时，不会发生冲突。是一种不需要使用忙碌等待（busy waiting）的一种方法。
信号量的概念是由荷兰计算机科学家艾兹格·迪杰斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系中，二进制信号量（binary semaphore）又称Mutex。

计数信号量具备两种操作动作，之前称为 V（又称signal()）与 P（wait()）。 V操作会增加信号量 S的数值，P操作会减少它。
运作方式：
初始化，给与它一个非负数的整数值。
运行 P（wait()），信号量S的值将被减少。企图进入临界区段的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区段。
运行 V（又称signal()），信号量S的值会被增加。退出离开临界区段的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区段。


在同步的程序设计中，临界区段（Critical section）指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。
当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥或的使用，例如：semaphore。
只能被单一线程访问的设备，例如：打印机。
一个最简单的实现方法就是当线程/线程(Thread)进入临界区段时，禁止改变处理器；在uni-processor系统上，可以用"禁止中断(CLI)"来完成，避免在运行上下文交换(Context switching)的时候发生系统调用(System Call)；当离开临界区段时，处理器回撤消先的状态。

Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。




public Semaphore(int permits,boolean fair)创建具有给定的许可数和给定的公平设置的 Semaphore。
permits - 初始的可用许可数目。此值可能为负数，在这种情况下，必须在授予任何获取前进行释放。
fair - 如果此信号量保证在争用时按先进先出的顺序授予许可，则为 true；否则为 false。










7.Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。Exchanger的典型应用场景是：一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被消费。


五.性能调优

1.“微基准测试”(SimpleMicroBenchmark):这个术语通常指在隔离的，脱离上下文的情况下对某个特性进行性能测试。



------------------------------------------------------------
1.阻塞队列(BlockingQueue):
(1)在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。 单单抽象出生产者和消费者，还够不上是生产者／消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据 。
(2)假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。



ThreadPoolExecutor
ScheduledThreadPoolExecutor
ExecutorService


CopyOnWriteArrayList


于是百度谷歌了一下相关资料。原来我写的内部类是动态的，也就是开头以public class开头。而主程序是public static class main。在Java中，类中的静态方法不能直接调用动态方法。只有将某个内部类修饰为静态类，然后才能够在静态类中调用该类的成员变量与成员方法。所以解决办法是将public class改为public static class.


