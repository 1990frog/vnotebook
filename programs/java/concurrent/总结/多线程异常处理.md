[TOC]

# 举个例子
放学了，小朋友们排着队，跟着老师，走向校门口。老师停，学生停；老师走，学生走。瞎跑是不行的。 到了门口，来了二十个家长，接了二十个小朋友，各回各家，老师也回家了。

校内的路，老师和同学可以看作在一个线程内的，顺序执行，前边的停下来，后边的必须等。

到了门口，家长接了，就等于分出了一个线程，二十个家长，二十个线程，每个线程负责把自己的孩子送回家，线程之间没有次序依赖，同时进行。 如果一个线程出了异常，比如跟家长回家的路上，一个小朋友跌倒了，要去医院。显然，这不影响其的小朋友回家，也不该归放了学的老师管。是由受伤小朋友的家长处理，也就是说，异常应由所在的线程处理，别的线程没有义务或上下文，来处理你的异常。 本质上来说，分一个线程，意味着不必等。就像老师不必等待所有孩子都到家才下班。

不必等，意味着不知道其他线程的进度，也不必处理其他线程的问题。

孩子摔倒时，老师可能已经到家了，就好像题主的代码里，新线程里出异常，原线程可能已经跑完了。

# 线程与异常
每一个Java应用程序都是一个进程，在进程中会启动多个线程来执行各类任务。
因为Java线程的本质，所以当在一个Java的线程中抛出异常的时候，需要在当前线程中catch并处理。
如果当前线程没有catch住这个异常，那么这个异常就会被抛出，并导致这个线程运行终止。
因此对于Java的线程异常处理只能由当前线程来处理，其他线程是无法感知的。

# UncaughtExceptionHandler
为什么使用UncaughtExceptionHandler？
+ 主线程可以轻松发现异常，而子线程却不行
+ 子线程异常无法用传统方法捕获
+ 提高健壮性

```java
/**
 * 描述：
 * 自己的MyUncaughtExceptionHanlder
 */
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {

    private String name;

    public MyUncaughtExceptionHandler(String name) {
        this.name = name;
    }

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.WARNING, "线程异常，终止啦" + t.getName());
        System.out.println(name + "捕获了异常" + t.getName() + "异常");
    }
}
```

```java
/**
 * 描述：
 * 使用刚才自己写的UncaughtExceptionHandler
 */
public class UseOwnUncaughtExceptionHandler implements Runnable {

    public static void main(String[] args) throws InterruptedException {

        //设置异常捕获器
        Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler("捕获器1"));

        new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-1").start();
        Thread.sleep(300);
        new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-2").start();
        Thread.sleep(300);
        new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-3").start();
        Thread.sleep(300);
        new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-4").start();

    }


    @Override
    public void run() {
        throw new RuntimeException();
    }
}
```

