[TOC]

# 两大使用场景
+ 经典场景1：每个线程需要一个独享的对象（通常是工具类【非线程安全的】，典型需要使用的类有SimpleDateFormat和Random）
+ 经典常见2：每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦

两个出发点：
1.线程不安全的类
2.避免参数传递的麻烦

# 场景1：每个线程需要一个独享的对象
每个Thread内有<font color="red">自己</font>的实例副本，<font color="red">不共享</font>
比喻：<font color="red">教材</font>只有一本，一起做笔记有线程安全问题。<font color="red">复印</font>后没问题

SImpleDateFormat的进化之路：
代码
![](_v_images/20200102231559095_1471458608.png)
![](_v_images/20200102231951773_1025428214.png)

如果延伸为10个线程
可以使用for循环

但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）
将线程和其执行的内容解耦

![](_v_images/20200104211251584_280172554.png)
重复创建对象浪费资源
![](_v_images/20200104211543157_400429981.png)

# SimpleDateFormat的进化之路
1. 2个线程分别用自己的SimpleDateFormat，这没问题
2. 后来延伸出10个，那就有10个线程和10个SimpleDateFormat，这虽然写法不优雅（应该复用对象），但勉强可以接受
3. 但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）
4. 所有的线程共有同一个SimpleDateFormat对象
5. 这是线程不安全的，出现了并发安全问题
6. 我们可以选择加锁，加锁结果正常，但是效率低
7. 在这里更好的解决方案是使用ThreadLocal
8. lambda表达式

![](_v_images/20200104213234159_48898638.png)
在10个线程中，每个线程持有一个SimpleDateFormat对象

![](_v_images/20200104214217959_855914360.png)

# 场景二
![](_v_images/20200104214834615_812053004.png)

目标：每个线程内需要保存全局变量，可以让不同方法直接使用，避免参数传递的麻烦

方法：用ThreadLocal保存一些业务内容（用户权限信息、从用户系统获取到的用户名、userId等）

这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的

![](_v_images/20200105131900185_612456124.png)

![](_v_images/20200105131943578_27044356.png)

![](_v_images/20200105132157303_1049040396.png)

![](_v_images/20200105132244606_778847805.png)

![](_v_images/20200105132339813_597165471.png)
用法不一样，对应两种不同的场景

![](_v_images/20200105132605181_826724310.png)

![](_v_images/20200105133544736_1239593915.png)

# 总结
![](_v_images/20200105133921404_1063297835.png)

![](_v_images/20200105134032219_1106343314.png)

![](_v_images/20200105134132090_1945967253.png)
![](_v_images/20200105134231793_93997820.png)

# 使用ThreadLocal带来的好处
1. 达到线程安全
2. 不需要加锁，提高执行效率
3. 更高效地利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销
4. 免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度低，更优雅

# 原理、源码分析
搞清楚Thread、ThreadLocal以及ThreadLocalMap三者之间的关系
![](_v_images/20200105204551200_683093004.png)

# ThreadLocal的重要方法
![](_v_images/20200105205352567_1019286735.png)

![](_v_images/20200105205453669_1158386195.png)

![](_v_images/20200105205555805_1393732310.png)

![](_v_images/20200105210122919_1764930682.png)

![](_v_images/20200105210308942_565508001.png)
![](_v_images/20200105210348237_347771061.png)

![](_v_images/20200105210641770_746148682.png)

![](_v_images/20200105210744297_823481737.png)

![](_v_images/20200105210904072_799281815.png)

![](_v_images/20200105210957171_932150540.png)

![](_v_images/20200105211222669_2062640510.png)