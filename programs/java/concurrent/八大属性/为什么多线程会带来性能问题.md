[TOC]

1.调度：上下文切换
（可运行的线程数量超过cpu时会发生）
什么是上下文：保存现场
缓存开销：缓存失效
何时会导致密集的上下文切换：抢锁、IO
2.协作：内存同步

线程安全：
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方3进行任何其他的协作操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的

主要两个问题：
1.数据争用：数据读写由于同时写，会造成错误数据。
2.竞争条件：及时不是同时写造成的错误数据，由于顺序原因依然会造成错误，例如在写入前就读取了。

什么情况下会出现线程安全问题，怎么避免：
1.运行结果错误（a++多线程下出现消失的请求现象，属于read-modify-write）
2.死锁等活跃性问题（包括死锁、活锁、饥饿）
3.对象发布和初始化的时候的安全问题：
什么是发布：
1.声明为public
2.return一个对象
3.把对象作为参数传递到其他类的方法中
什么是逸出：
方法返回一个private对象（private的本意是不让外部访问）
还未完成初始化（构造函数没完全执行完毕）就把对象提供给外界：
1）在构造函数中未初始化完毕就this赋值
2）隐式逸出——注册监听事件
3）构造函数中运行线程
如何解决逸出：
副本、工厂模式

总结归纳：各种需要考虑线程安全的情况
1.访问共享的变量或资源、会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等
2.所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：
1）read-modify-write操作：一个线程读取了一个共享数据，并在此基础上更新该数据。该例子在上面的index++已经展示过了。
2）check-then-act操作：一个线程读取了一个共享数据，并在此基础上决定其下一个操作：
3.不同的数据之间存在捆绑关系的时候：ip和端口号
4.我们使用其他类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题：
比如hashmap没有声明自己是并发安全的，所以我们并发调用会出错


# 性能问题有哪些体现、什么是性能问题：

1.服务响应慢、吞吐量低、资源消耗（例如内存）过高等
2.虽然不是结果错误，但依然危害巨大
3.引入多线程不能本末倒置

为什么会有性能问题：
1.调度：上下文切换
2.协作：内存同步

