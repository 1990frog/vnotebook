# Object类与Thread类

1.为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？

2.多种方式实现生产者模式

3.Join和sleep和wait期间线程的状态分别是什么？为什么？ 

|   类   |            方法名             |                                                         简介                                                          |
| ------ | ----------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| Thread | sleep相关                     | 本表格的“相关”，指的是重载方法，也就是方法名相同，但是参数不同，例如sleep有多个方法，只是参数不同，实际作用大同小异 |
|        | join                          | 等待其他线程执行完毕                                                                                                  |
|        | yield相关                     | 放弃已获取到的cpu资源                                                                                                 |
|        | currentThread                 | 获取当前执行线程的引用                                                                                                |
|        | start,run相关                 | 启动线程相关                                                                                                          |
|        | interrupt相关                 | 中断线程                                                                                                              |
|        | stop(),suspend(),resume()相关 | 已废弃                                                                                                                |
| Object | wait/notify/notifyAll相关     | 让线程暂时休息和唤醒                                                                                                  |


# 阻塞阶段

直到以下4种情况之一发生时，才会被唤醒
1.另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程；
2.另一个线程调用这个对象的notifyAll()方法；
3.过了wait(long timeout)规定的超时时间，如果传入0就是永久等待；
4.线程自身调用了interrupt()

唤醒阶段
notify唤醒一个（操作系统调度）
notifyAll唤醒全部

遇到中断

# wait,notify,notifyAll特点、性质

1.用必须先拥有monitor
2.只能唤醒一个
3.属于Object类
4.类似功能的Condition
5.同时持有多个锁的情况


# sleep

sleep方法：
作用：我只想让线程在预期的时间执行，其他时候不要占用CPU资源，一旦调用sleep线程就会进入阻塞状态，就不会占用cpu资源。直到它下次被调度起来之后
特点：
不释放锁（包括synchronize和lock）
和wait不同，始终持有锁，而wait会释放锁

sleep方法响应中断
1.抛出InterruptedException
2.清除中断状态

sleep第二种写法（更优雅）：TimeUnit

sleep方法可以让线程进入Waiting状态，并且不占用cpu资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态

wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）
相同：
1.wait和sleep方法都可以使线程阻塞，对应线程状态是waiting或time_waiting。
2.wait和sleep方法都可以响应中断Thread.interrupt（）。
不同：
1.wait方法的执行必须在同步方法中进行，而sleep则不需要。
2.在同步方法里执行sleep方法时，不会释放monitor锁，但是wait方法会释放monitor锁。
3.sleep方法短暂休眠之后会主动退出阻塞，而没有指定时间的wait方法则需要被其他线程中断后才能退出阻塞。
4.wait()和notify()，notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法。

# join方法作用、用法

作用：因为新的线程加入了我们，所以我们要等他执行完再出发
用法：main等待thread1执行完毕，注意谁等谁

join注意点
CountDownLatch或CyclicBarrier类

在join期间，线程处于哪种线程状态？
WAITING


# yield方法

作用：释放我的CPU时间片，但是不会释放锁，也不会陷入阻塞
定位：JVM不保证遵循，为了保证程序的稳定性，一般开发中不使用yield，但是这个方法，并发包的类中运用的场合比较多。

yield与sleep区别：是否随时可能再次被调度

![20191015225811144_553346380](_v_images/20191022143600593_1213672566.png)