# final关键字总结

一．Final简介

许多编译语言都有某种方法，来向编译器告知一块数据是恒定不变的。有时数据的恒定不变是很有用的，比如：  
(1)一个永不改变的编译时常量。（注:我们不能因为某些数据是final的就认为在编译时可以知道它的值。在运行时使用随机生成的数值来初始化可以证明这一点）  
(2)一个在运行时被初始化的值，而你不希望它被改变。  

对于编译期常量这种情况，编译器可以将该变量值代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式，这减轻了一些运行时的负担。在Java中，这类常量必须是基本数据类型，并且以关键字final表示。在对这个常量进行定义的时候，必须对其进行赋值。

一个既是static又是final的域只占据一段不能改变的存储空间。当对对象引用而不是基本类型运用final时，其含义会有一点令人迷惑。对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径（但可以自己编写类以取得使对象恒定不变的效果）。这一限制同样适用数组，它也是对象。

二．常量规范

带有恒定初始值（即，编译器常量）的final static基本类型全用大写字母命名，并且字与字之间用下划线隔开（延续自C）。

三．空白final

Java允许生成“空白final”，所谓空白final是指被声明为final但又未给定初始值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。但是，空白final在关键字final的使用上提供了更大的灵活性，为此，一个类中final域就可以做到根据对象而有所不同，却又保持其恒定不变的特性。必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。

四．匿名类中传递参数

Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象。这一特性主要用来向匿名内部类传递数据。

之所以需要声明为final，一是局部变量声明周期的问题，二是避免匿名类修改局部变量值造成数据不统一假象的问题。由于局部变量在方法结束时就消亡了，而匿名类对象可能还继续存在，所以要能保证访问外部的局部变量，就必须保存一份引用，我们通过编译后的class文件可以看到，匿名类将主类对象本身和涉及的局部变量通过构造函数传给自己的成员变量。这样问题就出现了，同一份局部变量数据保存了两个引用，而实际编程时假若在匿名类内部能对该变量赋其他值，这样外界变量还是外界变量根本没改变，所以为了避免这种误解才强制将其声明为final型。至于外部的成员变量为何能不加final直接访问，是因为他们本身就是同一份引用（主类对象通过匿名类构造函数作为匿名类成员变量所持有）。
设方法f被调用,从而在它的调用栈中生成了变量i,此时产生了一个局部内部类对象inner_object,它访问了该局部变量i .当方法f()运行结束后,局部变量i就已死亡了,不存在了.但:局部内部类对象inner_object还可能一直存在(只能没有人再引用该对象时,它才会死亡),它不会随着方法f()运行结束死亡.这时:出现了一个"荒唐"结果:局部内部类对象inner_object要访问一个已不存在的局部变量i!

五．final方法

（1）使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义。这是出于设计的考虑：想要确保在继承中使用方法行为保持不变，并且不会被覆盖。过去建议使用final方法的第二个原因是效率。

在Java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用（前期绑定）。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常方式而执行方法调用机制（将参数压入栈，跳至方法代码处并执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来替代方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码就会膨胀，因此可能看不到内嵌带来的任何性能提高，因此，所带来的性能提高会因为花费于方法内的时间量而被缩减。

在最近的Java版本中，虚拟机（特别是hospot技术）可以探测到这些情况，并优化去掉这些效率反而降低的额外的内嵌调用，因此不再需要使用final方法来进行优化了。事实上，这种做法正在逐渐地受到劝阻。在使用Java SE5/6时，应该让编译器和JVM去处理效率问题，只有在想要明确禁止覆盖时，才将方法设置为final的。

（2）将方法声明为final，那就说明你已经知道这个方法提供的功能已经满足你要求，不需要进行扩展，并且也不允许任何从此类继承的类来覆写这个方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。另外有一种被称为inline的机制，它会使你在调用final方法时，直接将方法主体插入到调用处，而不是进行例行的方法调用，例如保存断点，压栈等，这样可能会使你的程序效率有所提高，然而当你的方法主体非常庞大时，或你在多处调用此方法，那么你的调用主体代码便会迅速膨胀，可能反而会影响效率，所以你要慎用final进行方法定义。

六．final和private关键字

类中所有的private方法都隐式地指定为是final的。由于无法取用private方法，所以也就无法覆盖它。可以对private方法添加final修饰词，但这并不会给该方法增加任何额外的意义。

七．final类

（1）当将某个类的整体定义为final时（通过将关键字final置于它的定义之前），就表明了你不打算继承该类，而且也不允许别人这样做。换句话说，出于某种考虑，你对该类的设计永不需要做任何变动，或者出于安全的考虑，你不希望它有子类。final类的域可以根据个人的意愿选择为是或不是final。不论类是否被定义为final，相同的规则都适用于定义为final的域。然而，由于final类禁止继承，所以final类中所有的方法都隐式指定为是final的，因为无法覆盖它们。在final类中可以给方法添加final修饰词，但这不会添加任何意义。

（2）当你将final用于类身上时，你就需要仔细考虑，因为一个final类是无法被任何人继承的，那也就意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。对于final类中的成员，你可以定义其为final，也可以不是final。而对于方法，由于所属类为final的关系，自然也就成了final型的。你也可以明确的给final类中的方法加上一个final，但这显然没有意义。

