[TOC]

# 树
+ 节点的度：一个节点含有的子树的个数称为该节点的度；
+ 树的度：一棵树中，最大的节点度称为树的度；
+ 叶节点或终端节点：度为零的节点；
+ 非终端节点或分支节点：度不为零的节点；
+ 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
+ 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
+ 兄弟节点：具有相同父节点的节点互称为兄弟节点；
+ 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
+ 深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
+ 高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
+ 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
+ 节点的祖先：从根到该节点所经分支上的所有节点；
+ 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
+ 森林：由m（m>=0）棵互不相交的树的集合称为森林；


# 二叉树
二叉树具有唯一根节点
二叉树每个节点最多有两个孩子
二叉树每个节点最多有一个父亲
最底层节点称为叶子节点
```java
class Node{
    E e;
    Node left;//左孩子
    Node right;//右孩子
}
```
二叉树不一定是满的，一个节点也是二叉树

# 二分搜索树Binary Search Tree
+ 二分搜索树是二叉树
+ 二分搜索树的每个节点的值：大于其左子树的所有节点的值，小于其右子树的所有节点的值


# 三种遍历方式
+ 前序遍历
+ 中序遍历
+ 后序遍历

后序遍历的一个应用：
为二分搜索树释放内存

分治算法
回溯算法
动态规划算法

## 前序遍历 Preorder Traversal (DLR)应用学
前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。

![Sorted_binary_tree_preorder](_v_images/20200131165814029_976925127.svg)
深度优先遍历 - 前序遍历：
F, B, A, D, C, E, G, I, H.

# 中序遍历
![Sorted_binary_tree_inorder](_v_images/20200131170130403_348188434.svg)
深度优先遍历 - 中序遍历：
A, B, C, D, E, F, G, H, I.

# 后序遍历
![Sorted_binary_tree_postorder](_v_images/20200131170155306_456062943.svg)

深度优先搜索 - 后序遍历：
A, C, E, D, B, H, I, G, F.

# 层次遍历
![Sorted_binary_tree_breadth-first_traversal](_v_images/20200131170437809_1385816660.svg)
广度优先遍历 - 层次遍历：
F, B, G, A, D, I, C, E, H.

# 二分搜索树遍历的非递归实现
+ 二分搜索树遍历的非递归实现，比递归实现复制很多
+ 中序遍历和后序遍历的非递归实现更复杂
+ 中序遍历和后序遍历的非递归实现，实际应用不广

# 二分搜索树的顺序性
+ successor
+ predecessor

# 二分搜索树的floor和ceil

# 二分搜索树的rank

# 二分搜索树的select

# 维护size的二分搜索树
```java
class Node{
    Node left;
    Node right;
    E e;
    int size;//子元素数量
}
```
# 维护depth的二分搜索树
```java
class Node{
    Node left;
    Node right;
    E e;
    int depth;//深度，root：0，first：1
}
```
# 支持重复元素的二分搜索树
方法一：
```java
class Node{
    Node left;//小于等于root
    Node right;//大于root
    E e;
}
```
方法二：
```java
class Node{
    Node left;//小于root
    Node right;//大于root
    E e;
    int count;//重复个数
}
```

# 二分搜索复杂度分析
```
总共有n个元素。
第1次折半：还剩n/2个元素
第2次折半：还剩n/4个元素
第3次折半：还剩n/8个元素
……
第k次折半：还剩n/2^k个元素
最坏的情况下，最后还剩1个元素，令n/2^k = 1。得k=logn。
时间复杂度O(logn)
对折次数为树的高度O(h)
```
## 推算过程
第h层有多少个节点：
$n=2^{h-1}$
h层的树一共有多少个节点？
$n=2^0+2^1+2^2+\cdots+2^{h-1} = \frac{1*(1-2^h)}{1-2}=2^h-1$
复杂度推算：
$h=log2(n+1)=O(log2(n))=O(logn)$

