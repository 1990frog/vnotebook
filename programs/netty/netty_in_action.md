# netty_in_action

Netty基于异步与事件驱动

Netty网络抽象的代表：
Channel——Socket基本的I\O操作（bind()、connect()、read()和write()）
EventLoop——控制流、多线程处理、并发
ChannelFuture——异步通知

创建channel——>将channel注册到EventLoop中——>在整个生命周期内都使用EventLoop处理I/O事件

一个EventLoopGroup包含一个或者多个EventLoop
一个EventLoop在他的生命周期内只和一个Thread绑定
所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理
一个Channel在它的生命周期内只注册一个EventLoop
一个EventLoop可能会被分配给一个或多个Channel

ChannelHandler
它充当了所有入站和出站数据的应用程序逻辑的容器。
ChannelInboundHandler
ChannelOutboundHandler

ChannelPipeline接口
ChannelPipeline为ChannelHandler链提供了容器，并定义了用于在该链上传播入站和出站事件流的API.当Channel被创建时，它会被自动地分配到它专属的ChannelPipeline。
当ChannelHandler被添加到ChannelPipeline时，它将会被分配一个ChannelHandler-Context，其代表了ChannelHandler和ChannelPipeline之间的绑定。虽然这个对象可以被用于获取底层的Channel，但是它主要还是被用于写出站数据。

适配器模式要学

两种引导方式：
Bootstrap
ServerBootstrap

引导一个客户端只需要一个EventLoopGroup
引导一个服务的可能需要两个（也可能是一个，同一个EventLoopGroup）

Server:
bossGroup：监听端口嵌套字
workerGroup：处理传入客户端链接