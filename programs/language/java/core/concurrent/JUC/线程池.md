[TOC]

# 概览
## 什么是池（享元模式）
软件中的池，可以理解为计划经济
如果不使用线程池，每个任务都新开一个线程处理（开销太大）
## 为什么要使用线程池
### 反复创建线程开销大
用少量的线程——避免内存占用过多
### 过多的线程会占用太多内存
让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗
## 线程池适合应用的场合
+ 服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率
+ 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理
# 线程池构造函数参数
|              参数名               |                             意义                              |
| --------------------------------- | ------------------------------------------------------------- |
| corePoolSize(int)                 | 核心线程数                                                    |
| maxPoolSize(int)                  | 最大线程数                                                    |
| keepAliveTime(long)               | 保持存活时间                                                  |
| workQueue(BlockingQueue)          | 任务存储队列                                                  |
| threadFactory(ThreadFactory)      | 当线程池需要新的线程的时候，会使用ThreadFactory来生成新的线程 |
| Handler(RejectedExecutionHandler) | 由于线程无法接受你所提交的任务的拒绝策略                      |
## corePoolSize
corePoolSize指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新线程去执行任务
##  maximumPoolSize(maxPoolSize)
线程池也可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maxPoolSize
maximumPoolSize和maxPoolSize的含义相同，不做额外区分。实际上，在ThreadPoolExecutor类的参数中，变量名是maximumPoolSize；不过在org.springframework.scheduling.concurrent包的ThreadPoolExecutorFactoryBean类等其他类中，也有使用maxPoolSize作为参数名的情况，我们直接理解为maximumPoolSize和maxPoolSize相同的就可以了
### 添加线程规则
1. 如果线程数小于coolPoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务
2. 如果线程数等于（或大于）corePoolSize但少于maximumPoolSize，则将任务放入队列
3. 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务
4. 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务

线程池：核心池大小为5，最大池大小为10，队列为100
因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务就拒绝。
### 例子
烧烤店的桌子，里面的桌子始终存在，外面摆的桌子也是有限的，可以被处理
### 增减线程的特点
1. 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池
2. 线程池希望保持较少的线程数，并且只有在负债变得很大时才增加它
3. 通过设置maximumPoolSize为很高的值，例如：Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务
4. 是只有队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize
## keepAliveTime
keepAliveTime指的是当当前线程池中线程大于corePoolSize 的时候，如果超过 keepAliveTime 还没有新的任务，则释放大于 corePoolSize 部分的线程
### 怎么实现的？
## ThreadFactory用来创建线程
+ 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等
+ 通常我们用默认的ThreadFactory就可以了
### 看看源码
## workQueue
有3种最常见的队列类型：
+ 直接交接：SynchronousQueue
+ 无界队列：LinkedBlockingQueue
+ 有界队列：ArrayBlockingQueue
# 线程池状态
+ RUNNING：接受新任务并处理排队任务
+ SHUTDOWN：不接受新任务，但处理排队任务
+ STOP：不接受新任务，也不处理排队任务，并中断正在进行的任务
+ TIDYING：中文是整洁，理解了中文就容易理解这个状态了，所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法
+ TERMINATED：terminate()运行完成
# 线程池应该手动创建还是自动创建
+ 手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险
+ 自动创建的线程池（也就是直接调用JDK封装好的构造函数）可能带来一些问题
+ 正确的创建线程池的方法：根据不同的业务场景，自己设置线程池参数，比如我们的内存有多大，我们想给线程取什么名字等等
# 线程池的线程数量设置为多少比较合适
+ cpu密集型（加密、计算hash等）：最佳线程数为cpu核心数的1-2倍左右
+ 耗时io型（读写数据库、文件、网络读写等）：最佳线程数一般会大于cpu核心数很多倍，以jvm线程监控显示繁忙情况为依据，保证线程空闲可以衔接上，参考Brain Goetz推荐的计算方法：线程数=cpu核心数*(1+平均等待时间/平均工作时间)
# Executors创建线程池
+ ExecutorService
+ ScheduledExecutorService
+ ForkJoinPool
## 4种线程池的构造函数的参数

|   Parameter   |   FixedThreadPool    | CachedThreadPool  | ScheduledThreadPool |   SingleThreaded    |
| ------------- | -------------------- | ----------------- | ------------------- | ------------------- |
| corePoolSize  | constructor-arg      | 0                 | contructor-arg      | 1                   |
| maxPoolSize   | same as corePoolSize | Integer.MAX_VALUE | Integer.MAX_VALUE   | 1                   |
| keepAliveTime | 0 seconds            | 60 seconds        | 0 seconds           | 0 seconds           |
| workQueue     | LinkedBlockingQueue  | SynchronousQueue  | DelayedWorkQueue    | LinkedBlockingQueue |

## newFixedThreadPool

```java
/**
 * Creates a thread pool that reuses a fixed number of threads
 * operating off a shared unbounded queue.  At any point, at most
 * {@code nThreads} threads will be active processing tasks.
 * If additional tasks are submitted when all threads are active,
 * they will wait in the queue until a thread is available.
 * If any thread terminates due to a failure during execution
 * prior to shutdown, a new one will take its place if needed to
 * execute subsequent tasks.  The threads in the pool will exist
newSingleThreadExecutor
可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存

CachedThreadPool
可缓存线程池
特点：无界线程池，具有自动回收多余线程的功能
newCachedThreadPool
这里的弊端在于第二个参数maximumPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至
 * until it is explicitly {@link ExecutorService#shutdown shutdown}.
 *
 * @param nThreads the number of threads in the pool
 * @return the newly created thread pool
 * @throws IllegalArgumentException if {@code nThreads <= 0}
 */
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```
### 构造参数
+ corePoolSize：自定义
+ maxPoolSize：自定义
+ keepAliveTime：不设置
+ workQueue：LinkedBlockingQueue无界队列
### 注意
由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM(OutOfMemoryError)
测试：
```
设置VM options: -Xmx8m -Xms8m
```

## newSingleThreadExecutor
+ 单线程的线程池：它只会用唯一的工作线程来执行任务
+ 它的原理和FixedThreadPool是一样的，但是此时的线程数量被设置为了1

```java
/**
 * Creates an Executor that uses a single worker thread operating
 * off an unbounded queue. (Note however that if this single
 * thread terminates due to a failure during execution prior to
 * shutdown, a new one will take its place if needed to execute
 * subsequent tasks.)  Tasks are guaranteed to execute
 * sequentially, and no more than one task will be active at any
 * given time. Unlike the otherwise equivalent
 * {@code newFixedThreadPool(1)} the returned executor is
 * guaranteed not to be reconfigurable to use additional threads.
 *
 * @return the newly created single-threaded Executor
 */
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

### 构造参数
+ corePoolSize：1
+ maxPoolSize：1
+ keepAliveTime：不设置
+ workQueue：LinkedBlockingQueue无界队列
### 注意
可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存
## CachedThreadPool

```java
/**
 * Creates a thread pool that creates new threads as needed, but
 * will reuse previously constructed threads when they are
 * available.  These pools will typically improve the performance
 * of programs that execute many short-lived asynchronous tasks.
 * Calls to {@code execute} will reuse previously constructed
 * threads if available. If no existing thread is available, a new
 * thread will be created and added to the pool. Threads that have
 * not been used for sixty seconds are terminated and removed from
 * the cache. Thus, a pool that remains idle for long enough will
 * not consume any resources. Note that pools with similar
 * properties but different details (for example, timeout parameters)
 * may be created using {@link ThreadPoolExecutor} constructors.
 *
 * @return the newly created thread pool
 */
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```
### 构造参数
+ corePoolSize：0
+ maxPoolSize：Integer.MAX_VALUE
+ keepAliveTime：60秒
+ workQueue：SynchronousQueue零容量，立即交换队列
### 特点
+ 可缓存线程池
+ 无界线程池，具有自动回收多余线程的功能（60s就挂了）
+ 这里的弊端在于第二个参数maximumPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM
## ScheduledThreadPool
支持定时及周期性任务执行的线程池

```java
/**
 * Creates a thread pool that can schedule commands to run after a
 * given delay, or to execute periodically.
 * @param corePoolSize the number of threads to keep in the pool,
 * even if they are idle
 * @return a newly created scheduled thread pool
 * @throws IllegalArgumentException if {@code corePoolSize < 0}
 */
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```
ScheduledExecutorService.class
```java
/**
 * Creates and executes a periodic action that becomes enabled first
 * after the given initial delay, and subsequently with the given
 * period; that is executions will commence after
 * {@code initialDelay} then {@code initialDelay+period}, then
 * {@code initialDelay + 2 * period}, and so on.
 * If any execution of the task
 * encounters an exception, subsequent executions are suppressed.
 * Otherwise, the task will only terminate via cancellation or
 * termination of the executor.  If any execution of this task
 * takes longer than its period, then subsequent executions
 * may start late, but will not concurrently execute.
 *
 * @param command the task to execute
 * @param initialDelay the time to delay first execution
 * @param period the period between successive executions
 * @param unit the time unit of the initialDelay and period parameters
 * @return a ScheduledFuture representing pending completion of
 *         the task, and whose {@code get()} method will throw an
 *         exception upon cancellation
 * @throws RejectedExecutionException if the task cannot be
 *         scheduled for execution
 * @throws NullPointerException if command is null
 * @throws IllegalArgumentException if period less than or equal to zero
 */
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);
```
### 参数
+ command：Runnable
+ initialDelay：延迟首次执行的时间
+ period：两次执行之间的时间间隔
+ unit：时间单位

## workStealingPool是jdk1.8加入的（有点难哦ForkJoinPool）
+ 这个线程池和之前的都有很大不同
+ 子任务
+ 窃取

不保障顺序，如果任务是递归的，会产生子任务适合这种线程池

# 停止线程池的正确方法
+ shutDown()
+ isShutDown()
+ isTerminated()
+ awaitTermination()
+ shutdownNow() # 发送interrupted，队列里的直接返回
List<Runnable> runnableList = executorService.shutdownNow()

# 任务太多，怎么拒绝？
拒绝时机：
1. 当Executor关闭时，提交新任务会被拒绝
2. 以及当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时

# 4种拒绝策略
+ AbortPolicy
+ DiscardPolicy
+ DiscardOldestPolicy
+ CallerRunsPolicy

# 钩子方法，给线程池加点料
+ 每个任务执行前后
+ 日志、统计

暂停功能的实现

# 实现原理、源码分析
线程池组成部分：
+ 线程池管理器
+ 工作线程
+ 任务队列
+ 任务接口（Task）

# Executor家族
线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，大家都是什么关系？

# 源码
## 线程池实现任务复用的原理
相同线程执行不同任务
```java
public class ThreadPoolExecutor{
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();//直接调用Runnable的run方法
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
}
```

# 使用线程池的注意事项
+ 避免任务堆积
```java
if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    if (! isRunning(recheck) && remove(command))
        reject(command);
    else if (workerCountOf(recheck) == 0)
        addWorker(null, false);
}
else if (!addWorker(command, false))
    reject(command);
```
+ 避免线程数过度增加
+ 排查线程泄露