[TOC]

# 概览
## 什么是池（享元模式）
软件中的池，可以理解为计划经济
如果不使用线程池，每个任务都新开一个线程处理（开销太大）
## 为什么要使用线程池
+ 反复创建线程开销大：用少量的线程——避免内存占用过多
+ 过多的线程会占用太多内存：让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗
## 线程池适合应用的场合
+ 服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率
+ 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理
## 线程池状态
+ RUNNING：接受新任务并处理排队任务
+ SHUTDOWN：不接受新任务，但处理排队任务
+ STOP：不接受新任务，也不处理排队任务，并中断正在进行的任务
+ TIDYING：中文是整洁，理解了中文就容易理解这个状态了，所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate()钩子方法
+ TERMINATED：terminate()运行完成
## 线程池应该手动创建还是自动创建
+ 手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险
+ 自动创建的线程池（也就是直接调用JDK封装好的构造函数）可能带来一些问题
+ 正确的创建线程池的方法：根据不同的业务场景，自己设置线程池参数，比如我们的内存有多大，我们想给线程取什么名字等等
## 线程池的线程数量设置为多少比较合适
+ cpu密集型（加密、计算hash等）：最佳线程数为cpu核心数的1-2倍左右
+ 耗时io型（读写数据库、文件、网络读写等）：最佳线程数一般会大于cpu核心数很多倍，以jvm线程监控显示繁忙情况为依据，保证线程空闲可以衔接上，参考Brain Goetz推荐的计算方法：线程数=cpu核心数*(1+平均等待时间/平均工作时间)
# 线程池构造函数参数
|              参数名               |                             意义                              |
| --------------------------------- | ------------------------------------------------------------- |
| corePoolSize(int)                 | 核心线程数                                                    |
| maxPoolSize(int)                  | 最大线程数                                                    |
| keepAliveTime(long)               | 保持存活时间                                                  |
| workQueue(BlockingQueue)          | 任务存储队列                                                  |
| threadFactory(ThreadFactory)      | 当线程池需要新的线程的时候，会使用ThreadFactory来生成新的线程 |
| Handler(RejectedExecutionHandler) | 由于线程无法接受你所提交的任务的拒绝策略                      |
## corePoolSize
corePoolSize指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新线程去执行任务
## maximumPoolSize(maxPoolSize)
线程池也可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maxPoolSize
maximumPoolSize和maxPoolSize的含义相同，不做额外区分。实际上，在ThreadPoolExecutor类的参数中，变量名是maximumPoolSize；不过在org.springframework.scheduling.concurrent包的ThreadPoolExecutorFactoryBean类等其他类中，也有使用maxPoolSize作为参数名的情况，我们直接理解为maximumPoolSize和maxPoolSize相同的就可以了
### 添加线程规则
1. 当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。
2. 当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行
3. 当workQueue已满，且maximumPoolSize>corePoolSize时，新提交任务会创建新线程执行任务
4. 当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理（拒绝任务）
5. 当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程
6. 当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭

线程池：核心池大小为5，最大池大小为10，队列为100
因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务就拒绝。
### 例子
烧烤店的桌子，里面的桌子始终存在，外面摆的桌子也是有限的，可以被处理
### 增减线程的特点
1. 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池
2. 线程池希望保持较少的线程数，并且只有在负载变得很大时才增加它
3. 通过设置maximumPoolSize为很高的值，例如：Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务
4. 是只有队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize
## keepAliveTime
keepAliveTime指的是当当前线程池中线程大于corePoolSize 的时候，如果超过 keepAliveTime 还没有新的任务，则释放大于 corePoolSize 部分的线程
### 源码
```java
/**
 * Sets the policy governing whether core threads may time out and
 * terminate if no tasks arrive within the keep-alive time, being
 * replaced if needed when new tasks arrive. When false, core
 * threads are never terminated due to lack of incoming
 * tasks. When true, the same keep-alive policy applying to
 * non-core threads applies also to core threads. To avoid
 * continual thread replacement, the keep-alive time must be
 * greater than zero when setting {@code true}. This method
 * should in general be called before the pool is actively used.
 *
 * @param value {@code true} if should time out, else {@code false}
 * @throws IllegalArgumentException if value is {@code true}
 *         and the current keep-alive time is not greater than zero
 *
 * @since 1.6
 */
public void allowCoreThreadTimeOut(boolean value) {
    if (value && keepAliveTime <= 0)
        throw new IllegalArgumentException("Core threads must have nonzero keep alive times");
    if (value != allowCoreThreadTimeOut) {
        allowCoreThreadTimeOut = value;
        if (value)
            interruptIdleWorkers();
    }
}
```
## ThreadFactory用来创建线程
+ 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等
+ 通常我们用默认的ThreadFactory就可以了

ThreadFactory接口
```java
public interface ThreadFactory {

    /**
     * Constructs a new {@code Thread}.  Implementations may also initialize
     * priority, name, daemon status, {@code ThreadGroup}, etc.
     *
     * @param r a runnable to be executed by new thread instance
     * @return constructed thread, or {@code null} if the request to
     *         create a thread is rejected
     */
    Thread newThread(Runnable r);
}
```
Executors.DefaultThreadFactory默认的ThreadFactory
```java
/**
 * The default thread factory
 */
static class DefaultThreadFactory implements ThreadFactory {
    private static final AtomicInteger poolNumber = new AtomicInteger(1);
    private final ThreadGroup group;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    DefaultThreadFactory() {
        SecurityManager s = System.getSecurityManager();
        group = (s != null) ? s.getThreadGroup() :
                              Thread.currentThread().getThreadGroup();
        namePrefix = "pool-" +
                      poolNumber.getAndIncrement() +
                     "-thread-";
    }

    public Thread newThread(Runnable r) {
        Thread t = new Thread(group, r,
                              namePrefix + threadNumber.getAndIncrement(),
                              0);
        if (t.isDaemon())
            t.setDaemon(false);
        if (t.getPriority() != Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        return t;
    }
}
```
## workQueue
有3种最常见的队列类型：
+ 直接交接：SynchronousQueue
+ 无界队列：LinkedBlockingQueue
+ 有界队列：ArrayBlockingQueue
+ DelayedWorkQueue
# 创建：Executors工具类（工厂模式）
+ ExecutorService
+ ScheduledExecutorService
+ ForkJoinPool
## 4种线程池的构造函数的参数
|   Parameter   |   FixedThreadPool    | CachedThreadPool  | ScheduledThreadPool |   SingleThreaded    |
| ------------- | -------------------- | ----------------- | ------------------- | ------------------- |
| corePoolSize  | constructor-arg      | 0                 | contructor-arg      | 1                   |
| maxPoolSize   | same as corePoolSize | Integer.MAX_VALUE | Integer.MAX_VALUE   | 1                   |
| keepAliveTime | 0 seconds            | 60 seconds        | 0 seconds           | 0 seconds           |
| workQueue     | LinkedBlockingQueue  | SynchronousQueue  | DelayedWorkQueue    | LinkedBlockingQueue |
## newFixedThreadPool

```java
/**
 * Creates a thread pool that reuses a fixed number of threads
 * operating off a shared unbounded queue.  At any point, at most
 * {@code nThreads} threads will be active processing tasks.
 * If additional tasks are submitted when all threads are active,
 * they will wait in the queue until a thread is available.
 * If any thread terminates due to a failure during execution
 * prior to shutdown, a new one will take its place if needed to
 * execute subsequent tasks.  The threads in the pool will exist
 * until it is explicitly {@link ExecutorService#shutdown shutdown}.
 *
 * @param nThreads the number of threads in the pool
 * @return the newly created thread pool
 * @throws IllegalArgumentException if {@code nThreads <= 0}
 */
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```
### 构造参数
+ corePoolSize：自定义
+ maxPoolSize：自定义
+ keepAliveTime：不设置
+ workQueue：LinkedBlockingQueue无界队列
### 注意
由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM(OutOfMemoryError)
测试：
```
设置VM options: -Xmx8m -Xms8m
```

## newSingleThreadExecutor
+ 单线程的线程池：它只会用唯一的工作线程来执行任务
+ 它的原理和FixedThreadPool是一样的，但是此时的线程数量被设置为了1

```java
/**
 * Creates an Executor that uses a single worker thread operating
 * off an unbounded queue. (Note however that if this single
 * thread terminates due to a failure during execution prior to
 * shutdown, a new one will take its place if needed to execute
 * subsequent tasks.)  Tasks are guaranteed to execute
 * sequentially, and no more than one task will be active at any
 * given time. Unlike the otherwise equivalent
 * {@code newFixedThreadPool(1)} the returned executor is
 * guaranteed not to be reconfigurable to use additional threads.
 *
 * @return the newly created single-threaded Executor
 */
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

### 构造参数
+ corePoolSize：1
+ maxPoolSize：1
+ keepAliveTime：不设置
+ workQueue：LinkedBlockingQueue无界队列
### 注意
可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存
## CachedThreadPool

```java
/**
 * Creates a thread pool that creates new threads as needed, but
 * will reuse previously constructed threads when they are
 * available.  These pools will typically improve the performance
 * of programs that execute many short-lived asynchronous tasks.
 * Calls to {@code execute} will reuse previously constructed
 * threads if available. If no existing thread is available, a new
 * thread will be created and added to the pool. Threads that have
 * not been used for sixty seconds are terminated and removed from
 * the cache. Thus, a pool that remains idle for long enough will
 * not consume any resources. Note that pools with similar
 * properties but different details (for example, timeout parameters)
 * may be created using {@link ThreadPoolExecutor} constructors.
 *
 * @return the newly created thread pool
 */
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```
### 构造参数
+ corePoolSize：0
+ maxPoolSize：Integer.MAX_VALUE
+ keepAliveTime：60秒
+ workQueue：SynchronousQueue零容量，立即交换队列
### 特点
+ 可缓存线程池
+ 无界线程池，具有自动回收多余线程的功能（60s就挂了）
+ 这里的弊端在于第二个参数maximumPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM
## ScheduledThreadPool
支持定时及周期性任务执行的线程池

```java
/**
 * Creates a thread pool that can schedule commands to run after a
 * given delay, or to execute periodically.
 * @param corePoolSize the number of threads to keep in the pool,
 * even if they are idle
 * @return a newly created scheduled thread pool
 * @throws IllegalArgumentException if {@code corePoolSize < 0}
 */
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```
ScheduledExecutorService.java
```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());
}
```
### 参数
+ command：Runnable
+ initialDelay：延迟首次执行的时间
+ period：两次执行之间的时间间隔
+ unit：时间单位

## workStealingPool是jdk1.8加入的（有点难哦ForkJoinPool）
+ 这个线程池和之前的都有很大不同
+ 子任务
+ 窃取

不保障顺序，如果任务是递归的，会产生子任务适合这种线程池

# 终止：停止线程池的正确方法
+ shutDown()：不在接受任务，全部任务完成之后释放资源
+ isShutDown()：判断是否进入shutDown状态
+ isTerminated()：挂了
+ awaitTermination()
+ shutdownNow() ：发送interrupted，队列里的直接返回 List<Runnable> runnableList = executorService.shutdownNow()

# 拒绝：任务太多，怎么拒绝
## 拒绝时机
1. 当Executor关闭时，提交新任务会被拒绝
2. 以及当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时

## 4种拒绝策略
+ AbortPolicy
+ DiscardPolicy
+ DiscardOldestPolicy
+ CallerRunsPolicy

# 钩子方法，给线程池加点料
+ 每个任务执行前后
+ 日志、统计

暂停功能的实现

# 实现原理、源码分析
线程池组成部分：
+ 线程池管理器
+ 工作线程
+ 任务队列
+ 任务接口（Task）

# Executor家族
线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，大家都是什么关系？

# 源码
## 线程池实现任务复用的原理
相同线程执行不同任务
```java
public class ThreadPoolExecutor{
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }

    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();//直接调用Runnable的run方法
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
}
```

# 使用线程池的注意事项
+ 避免任务堆积
```java
if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    if (! isRunning(recheck) && remove(command))
        reject(command);
    else if (workerCountOf(recheck) == 0)
        addWorker(null, false);
}
else if (!addWorker(command, false))
    reject(command);
```
+ 避免线程数过度增加
+ 排查线程泄露

# Worker类
```java
/**
 * Class Worker mainly maintains interrupt control state for
 * threads running tasks, along with other minor bookkeeping.
 * This class opportunistically extends AbstractQueuedSynchronizer
 * to simplify acquiring and releasing a lock surrounding each
 * task execution.  This protects against interrupts that are
 * intended to wake up a worker thread waiting for a task from
 * instead interrupting a task being run.  We implement a simple
 * non-reentrant mutual exclusion lock rather than use
 * ReentrantLock because we do not want worker tasks to be able to
 * reacquire the lock when they invoke pool control methods like
 * setCorePoolSize.  Additionally, to suppress interrupts until
 * the thread actually starts running tasks, we initialize lock
 * state to a negative value, and clear it upon start (in
 * runWorker).
 */
private final class Worker extends AbstractQueuedSynchronizer implements Runnable{
    /**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```