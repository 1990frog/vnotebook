vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/programs/language/java/core/concurrent/JUC/各种锁.md
[TOC]

# Lock接口
+ 锁是一种工具，用于控制对共享资源的访问
+ Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。
+ Lock并不是用来代替synchronized的，而是当使用synchronized不适合或不足以满足要求的时候，来提供高级功能的。
+ Lock接口最常见的实现类是ReentrantLock
+ 通常情况下，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也允许并发访问，比如：ReadWriteLock里面的ReadLock
# Synchronized
## 优点
1. 自动释放锁
## 缺点
1. 效率低：锁释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程【排它锁，不可中断】
2. 不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的
3. 无法知道是否成功获取到锁【？】
# Lock主要方法介绍
源码：
```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```
## lock()
1. lock()就是最普通的获取锁。如果锁已被其他线程获取，则进行等待
2. Lock不会像synchronized一样在异常时自动释放锁
3. 因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放
4. lock()方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock()就会陷入永久等待
## tryLock()
1. tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败
2. 相比于lock，这样的方法显然功能更强大了，我们可以根据是否能获取锁来决定后续程序的行为
3. 该方法会立即返回，即便在拿不到锁时不会一直在那等
## tryLock(long time,TimeUnit unit)
超时就放弃
## lockInterruptibly()
相当于tryLock(long time,TimeUnit unit)把超时时间设置为无限。在等待锁的过程中，线程就可以被中断
## unlock()
释放锁
先解锁再写业务逻辑
# 可见性保证
happens-before
<font color="red">所有的锁都支持happensbefore吗？</font>
Lock的加解锁和synchronized有同样的内存语义，也就是说，下一个加锁前可以看到所有前一个解锁后发生的所有语句
![](_v_images/20200108205936127_1842023762.png)
# 锁的分类
+ 这些分类，是从各种不同角度出发去看的
+ 这些分类并不是互斥的，也就是多个类型可以并存：有可能一个锁，同时属性两种类型
+ ReentrantLock既是互斥锁，又是可重入锁
+ 好比一个人可以同时是男人，又是军人，这个不冲突
## 悲观锁（互斥同步锁）与乐观锁（非互斥同步锁）
线程要不要锁住同步资源
## 共享锁与独占锁
多线程是否共享一把锁
## 公平锁与非公平锁
多线程竞争时，是否排队
## 可重入锁（递归锁）与不可重入锁
同一个线程是否可以重复获取同一把锁
## 可中断锁与不可中断锁
是否可中断
## 自旋锁与非自旋锁
等锁的过程


---



---

# 公平锁和非公平锁
+ 公平指的是按照线程请求的顺序，来分配锁；非公平指的是，不完全按照请求的顺序，在一定情况下，可以插队
+ 注意：非公平也同样不提倡“插队”行为，这里的非公平，指的是“在合适的时机”插队，而不是盲目插队
+ 什么是合适的时机呢？
+ 火车票被插队的例子

## 为什么要有非公平锁
为了提高效率，避免唤醒带来的空档期

唤醒的开销很大，在此期间利用空档期提高吞吐量

女神找不到男朋友之间备胎来补救

## 公平的情况（以ReentrantLock为例）
如果在创建ReentrantLock对象时，参数填写为true，那么这就是个公平锁

+ 在线程1执行unlock()释放锁之后，由于此时线程2的等待时间最久，所以线程2先得到执行，然后是线程3和线程4

# 不公平的情况（以ReentrantLock为例）
+ 如果在线程1释放锁的时候，线程5恰好去执行lock()
+ 由于ReentrantLock发现此时并没有线程持有lock这把锁（线程2还没来得及获取到，因为获取需要时间）
+ 线程5可以插队，直接拿到这把锁，这也是ReentrantLock默认的公平策略，也就是“不公平”

# 特例
+ 针对tryLock()方法，它是很猛的，它不遵守设定的公平规则
+ 例如，当有线程执行tryLock()时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他线程现在在等待队列里了

# 对比公平和非公平的优缺点
|          |                           优势                           |                             劣势                             |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 公平锁   | 各线程公平平等，每个线程在等待一段时间后，总有执行的机会 | 更慢，吞吐量更小                                             |
| 非公平锁 | 更快，吞吐量更大                                         | 有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行 |


---

# 共享锁和排它锁
## 什么是共享锁和排它锁
+ 排它锁，又称为独占锁、独享锁
+ 共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据
+ 共享锁和排它锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁

# 读写锁的作用
+ 在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题
+ 在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，提高了程序的执行效率

# 读写锁的规则
+ 多个线程只申请读锁，都可以申请到
+ 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
+ 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。
+ 一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现（要么多读，要么一写）

# 读写锁的规则
+ 换一种思路更容易理解：读写锁只是一把锁，可以通过两种方式锁定：读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定
+ 这里是把“获取写锁”理解为“把读写锁进行写锁定”，相当于是换了一种思路，不过原则是不变的，就是要么是一个或多个线程同时有读锁（同时读锁定），要么是一个线程有写锁（进行写锁定），但是两者不会同时出现

# ReentrantReadWriteLock具体用法
+ 现在用了读写锁，线程1和线程2可以同时用读锁，提高了效率

# 读锁和写锁的交互方式
+ 选择规则
+ 读线程插队（比喻：男女共用厕所，男生可以插队吗？）
+ 升降级

# ReentrantReadWriteLock的实现
+ 插队：不允许读锁插队
+ 升降级：允许降级，不允许升级

# 读锁插队策略
+ 公平锁：不允许插队
+ 非公平锁
1. 写锁可以随时插队
2. 读锁仅在等待队列头结点不是想获取写锁的线程的时候可以插队



![](_v_images/20200111120824545_1300327867.png)

![](_v_images/20200111120903904_1846448772.png)

# 读锁插队策略
+ 公平锁：不允许插队
+ 非公平锁：
    1. 写锁可以随时插队
    2. 读书仅在等待队列头结点不是想获取写锁的线程的时候可以插队



插队不成功就去排队了

执行栈？？？有序？？？

公平锁在哪排队？

# 锁的升降级
+ 支持锁的降级，不支持升级
+ 为什么不支持锁的升级？死锁
如果a，b两个读锁都想升级写锁，那就会造成死锁

# 共享锁和排它锁总结
+ ReentrantReadWriteLock实现了ReadWriteLock接口，最主要有两个方法：readLock()和writeLock()用来获取读锁和写锁
+ 锁申请和释放策略
    1. 多个线程只申请读锁，都可以申请到
    2. 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
    3. 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁
    4. 要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。（总结：要么多读，要么一写）
+ 插队策略：为了防止饥饿，读锁不能插队
+ 升降机策略：只能降级，不能升级
+ 适用场合：相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率

---

# 自旋锁和阻塞锁
+ 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间
+ 如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长
+ 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失
+ 如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁
+ 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。
+ 阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到锁的情况，会直接把线程阻塞，直到被唤醒

# 自旋锁的缺点
+ 如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源
+ 在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的

# 原理和源码分析
+ 在java1.5版本以及以上的并发框架java.util.concurrent的atomic包下的类基本都是自旋锁的实现
+ AtomicInteger的实现：自旋锁的实现原理是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改过程中遇到其他线程竞争导致没修改成功，就在while里死循环，直到修改成功
![](_v_images/20200112144205909_2054446632.png)

自己实现一个简单的自旋锁：spinlock
# 自旋锁的适用场景
+ 自旋锁一般用于多核的处理器，在并发度不是特别高的情况下，比阻塞锁的效率高
+ 另外，自旋锁适用于临界区比较短小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），那也是不合适的


# 可中断锁
+ 在Java中，synchronized就不是可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断
+ 如果某一线程A正在执行锁中的代码，另一现场B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以中断它，这种就是可中断锁

# Java虚拟机对锁的优化
+ 自旋锁和自适应
+ 锁消除
+ 锁粗化

# 我们在写代码时如何优化锁和提高并发性能
1. 缩小同步代码块
2. 尽量不要锁住方法
3. 减少请求锁的次数
4. 避免人为制造“热点”
5. 锁中尽量不要再包含锁
6. 选择合适的锁类型或合适的工具类

# 锁总结
