vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/programs/language/java/core/concurrent/JUC/共享锁和排它锁.md
[TOC]

# 共享锁和排它锁
## 什么是共享锁和排它锁
+ 排它锁，又称为独占锁、独享锁
+ 共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据
+ 共享锁和排它锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁

# 读写锁的作用
+ 在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题
+ 在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，提高了程序的执行效率

# 读写锁的规则
+ 多个线程只申请读锁，都可以申请到
+ 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
+ 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。
+ 一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现（要么多读，要么一写）

# 读写锁的规则
+ 换一种思路更容易理解：读写锁只是一把锁，可以通过两种方式锁定：读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定
+ 这里是把“获取写锁”理解为“把读写锁进行写锁定”，相当于是换了一种思路，不过原则是不变的，就是要么是一个或多个线程同时有读锁（同时读锁定），要么是一个线程有写锁（进行写锁定），但是两者不会同时出现

# ReentrantReadWriteLock具体用法
+ 现在用了读写锁，线程1和线程2可以同时用读锁，提高了效率

# 读锁和写锁的交互方式
+ 选择规则
+ 读线程插队（比喻：男女共用厕所，男生可以插队吗？）
+ 升降级

# ReentrantReadWriteLock的实现
+ 插队：不允许读锁插队
+ 升降级：允许降级，不允许升级

# 读锁插队策略
+ 公平锁：不允许插队
+ 非公平锁
1. 写锁可以随时插队
2. 读锁仅在等待队列头结点不是想获取写锁的线程的时候可以插队



![](_v_images/20200111120824545_1300327867.png)

![](_v_images/20200111120903904_1846448772.png)

# 读锁插队策略
+ 公平锁：不允许插队
+ 非公平锁：
    1. 写锁可以随时插队
    2. 读书仅在等待队列头结点不是想获取写锁的线程的时候可以插队



插队不成功就去排队了

执行栈？？？有序？？？

公平锁在哪排队？

# 锁的升降级
+ 支持锁的降级，不支持升级
+ 为什么不支持锁的升级？死锁
如果a，b两个读锁都想升级写锁，那就会造成死锁

# 共享锁和排它锁总结
+ ReentrantReadWriteLock实现了ReadWriteLock接口，最主要有两个方法：readLock()和writeLock()用来获取读锁和写锁
+ 锁申请和释放策略
    1. 多个线程只申请读锁，都可以申请到
    2. 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
    3. 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁
    4. 要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。（总结：要么多读，要么一写）
+ 插队策略：为了防止饥饿，读锁不能插队
+ 升降机策略：只能降级，不能升级
+ 适用场合：相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率