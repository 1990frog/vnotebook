vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/programs/language/java/core/concurrent/JUC/共享锁和排它锁.md
[TOC]

# 什么是共享锁和排它锁
+ 排它锁，又称为独占锁、独享锁（Synchronized，ReentrantLock）
+ 共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据
+ 共享锁和排它锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁
# 读写锁的作用
+ 在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题
+ 在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，提高了程序的执行效率
# 读写锁的规则
+ 多个线程只申请读锁，都可以申请到
+ 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
+ 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁
+ 一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现（要么多读，要么一写）
+ 换一种思路更容易理解：**读写锁只是一把锁**，可以通过两种方式锁定：读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定
+ 这里是把“获取写锁”理解为“把读写锁进行写锁定”，相当于是换了一种思路，不过原则是不变的，就是要么是一个或多个线程同时有读锁（同时读锁定），要么是一个线程有写锁（进行写锁定），但是两者不会同时出现
# 读锁插队策略
+ 公平锁：不允许插队
+ 非公平锁：
    1. 写锁可以随时插队
    2. 读锁仅在等待队列头结点不是想获取写锁的线程的时候可以插队


# ReentrantReadWriteLock
+ 公平性选择：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；
+ 重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；
+ 锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁

```java
/**
 * Fair version of Sync
 */
static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() {
        return hasQueuedPredecessors();
    }
    final boolean readerShouldBlock() {
        return hasQueuedPredecessors();
    }
}

/**
 * Nonfair version of Sync
 */
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    final boolean readerShouldBlock() {
        /* As a heuristic to avoid indefinite writer starvation,
         * block if the thread that momentarily appears to be head
         * of queue, if one exists, is a waiting writer.  This is
         * only a probabilistic effect since a new reader will not
         * block if there is a waiting writer behind other enabled
         * readers that have not yet drained from the queue.
         */
        return apparentlyFirstQueuedIsExclusive();
    }
}
```
# 锁的升降级
+ 支持锁的降级，不支持升级
+ 为什么不支持锁的升级？死锁
如果a，b两个读锁都想升级写锁，那就会造成死锁

# 共享锁和排它锁总结
+ ReentrantReadWriteLock实现了ReadWriteLock接口，最主要有两个方法：readLock()和writeLock()用来获取读锁和写锁
+ 锁申请和释放策略
    1. 多个线程只申请读锁，都可以申请到
    2. 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁
    3. 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁
    4. 要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。（总结：要么多读，要么一写）
+ 插队策略：为了防止饥饿，读锁不能插队
+ 升降机策略：只能降级，不能升级
+ 适用场合：相比于ReentrantLock适用于一般场合，ReentrantReadWriteLock适用于读多写少的情况，合理使用可以进一步提高并发效率