[TOC]

# 概览
+ 又名递归锁
+ 可重入锁一定是非公平锁
+ Java中的可重入锁有两种：Synchronized与ReentrantLock
# 可重入的好处
+ 避免死锁（自己锁自己那种）
+ 提升封装性

递归调用不释放锁不停获取锁

# 可重入锁如何避免死锁
这是《java并发编程实例》一书中的例子，并且书中说：“如果synchronized不是可重入锁，那么LoggingWidget的super.dosomething()；无法获得Widget对象的锁，因为会死锁。”
```java
public class Widget {
    public synchronized void doSomething(){
        // do something
    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        super.doSomething();
    }
}
```
乍一看好像不是这么回事，就算synchronized不是可重入锁，可是synchronized关键字一个在父类Widget的方法上，另一个在子类LoggingWidget的方法上，怎么会有死锁产生呢?

这里其实牵涉到了Java的重写。我们看子类LoggingWidget的doSomething方法，重写了父类Widget的doSomething方法，但是子类对象如果要调用父类的doSomething方法，那么就需要用到super关键字了。因为实例方法的调用是Java虚拟机在运行时动态绑定的，子类LoggingWidget的对象调用doSomething方法，一定是绑定到子类自身的doSomething方法，必须用super关键字告诉虚拟机，这里要调用的是父类的doSomething方法。

实际上，如果我们分析运行时的LoggingWidget类，那我们看到的应该是这样子的（这里只是为了分析，真实情况肯定和下面的例子不同）：
```java
public class LoggingWidget extends Widget {
    public synchronized void Widget.doSomething() {
        // do something
    }   // 父类的doSomething方法

    public synchronized void doSomething() {
        super.doSomething();
    }
}
```
子类对象，其实是持有父类Widget的doSomething方法的，只需要使用super关键字告诉虚拟机要运行的是父类的doSomething方法，虚拟机会去调用子类对象中的父类Widget的doSomething方法的。所以，super关键字并没有新建一个父类的对象，比如说widget，然后再去调用widget.doSomething方法，实际上调用父类doSomething方法的还是我们的子类对象。

那么这样就很好理解了，如果一个线程有子类对象的引用loggingWidget，然后调用loggingWidget.doSomething方法的时候，会请求子类对象loggingWidget的对象锁；又因为loggingWidget的doSomething方法中调用的父类的doSomething方法，实际上还是要请求子类对象loggingWidget的对象锁，那么如果synchronized关键字不是个可重入锁的话，就会在子类对象持有的父类doSomething方法上产生死锁了。正因为synchronized关键字的可重入锁，当前线程因为已经持有了子类对象loggingWidget的对象锁，后面再遇到请求loggingWidget的对象锁就可以畅通无阻地执行同步方法了。

更进一步，将上面的示例代码改写一下，那么就算synchronized不是可重入锁，也不会产生死锁的问题了。代码如下：
```java
public class Widget {
    public synchronized void doSomething(){
        // do something
    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        Widget widget = new Widget();
        widget.doSomething();
    }
}
```

在子类的doSomething方法中，直接新建了一个父类的对象widget，然后用这个父类对象来调用父类的doSomething方法，实际上请求的是这个父类对象widget的对象锁，就不涉及到可重入锁的问题了。

# 源码对比
## 可重入锁ReentrantLock源码
```java
public boolean tryLock() {
    return sync.nonfairTryAcquire(1);
}
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();//Returns the current value of synchronization state
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        //获取锁时先判断，如果当前线程就是已经占有锁的线程，则state值+1，并返回true
        return true;
    }
    return false;
}

protected final boolean tryRelease(int releases) {
    //释放锁时也是先判断当前线程是否是已占有锁的线程，然后在判断status，如果status等于0，才真正的释放锁
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```
## 非可重入锁ThreadPoolExecutor的Worker类
```java
protected boolean tryAcquire(int unused) {
    //非重入锁是直接尝试获取锁
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}

protected boolean tryRelease(int unused) {
    setExclusiveOwnerThread(null);
    //释放锁也是直接将state置为0
    setState(0);
    return true;
}
```
## ReentrantLock的其他方法介绍
+ isHeldByCurrentThread可以看出锁是否被当前线程持有
+ getQueueLength可以返回当前正在等待这把锁的队列有多长，一般这两个方法是开发和调试时使用，上线用到的不多


# 可重入锁实现
```java

public class MyReentrantLock {

    boolean isLocked = false;
    Thread  lockedBy = null;
    int lockedCount = 0;

    public synchronized void lock()
            throws InterruptedException{
        Thread thread = Thread.currentThread();
        while(isLocked && lockedBy != thread){
            wait();
        }
        isLocked = true;
        lockedCount++;
        lockedBy = thread;
    }

    public synchronized void unlock(){
        if(Thread.currentThread() == this.lockedBy){
            lockedCount--;
            if(lockedCount == 0){
                isLocked = false;
                notify();
            }
        }
    }

}
```
# 不可重入锁实现
```java
public class MyUnReentrantLock{
    private boolean isLocked = false;
    public synchronized void lock() throws InterruptedException{
        while(isLocked){
            wait();
        }
        isLocked = true;
    }
    public synchronized void unlock(){
        isLocked = false;
        notify();
    }
}
```

---

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。

首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。

释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

要点：

可重入锁的一个优点是可一定程度避免死锁
AQS通过控制status状态来判断锁的状态，对于非可重入锁状态不是0则去阻塞；对于可重入锁如果是0则执行，非0则判断当前线程是否是获取到这个锁的线程，是的话把status状态＋1，释放的时候，只有status为0，才将锁释放。
