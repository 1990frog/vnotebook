[TOC]

# 概览
可重入锁一定是非公平锁
以ReentrantLock为例
电影院买票选座位

# 可重入的好处
+ 避免死锁
+ 提升封装性


递归调用不释放锁不停获取锁

# 源码对比
## 可重入锁ReentrantLock源码
```java
public boolean tryLock() {
    return sync.nonfairTryAcquire(1);
}
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();//Returns the current value of synchronization state
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        //获取锁时先判断，如果当前线程就是已经占有锁的线程，则status值+1，并返回true
        return true;
    }
    return false;
}

protected final boolean tryRelease(int releases) {
    //释放锁时也是先判断当前线程是否是已占有锁的线程，然后在判断status，如果status等于0，才真正的释放锁
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```
## 非可重入锁ThreadPoolExecutor的Worker类
```java
protected boolean tryAcquire(int unused) {
    //非重入锁是直接尝试获取锁
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}

protected boolean tryRelease(int unused) {
    setExclusiveOwnerThread(null);
    //释放锁也是直接将state置为0
    setState(0);
    return true;
}
```
## ReentrantLock的其他方法介绍
+ isHeldByCurrentThread可以看出锁是否被当前线程持有
+ getQueueLength可以返回当前正在等待这把锁的队列有多长，一般这两个方法是开发和调试时使用，上线用到的不多