[TOC]

# 概览
+ 悲观锁=互斥同步锁
+ 乐观锁=非互斥同步锁
+ cas对比monitor
# 悲观锁：Synchronized与Lock拓展类
+ 如果我不锁住这个资源，别人就回来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失
+ Synchronized的优点：自动释放锁
# 悲观锁的缺点
+ 阻塞和唤醒带来的性能劣势
+ 永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行
+ 优先级反转（优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证）
# 乐观锁：Atomic原子类、并发容器
+ 如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略
+ 乐观锁的实现一般都是利用CAS算法来实现的（乐观锁一般会使用版本号机制或CAS（Compare-and-Swap，即比较并替换）算法实现）

例子1：
1. 线程1发现没人在计算期间修改资源，于是把自己的计算结果写到资源里
2. 线程2计算完并判断资源是否已被修改，发现计算期间有人修改了资源，于是报错或重试

例子2：
Git就是乐观锁的典型例子，当我们往远端仓库push的时候，git会检查远端仓库版本是不是领先于我们现在的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码了，我们的这次提交就失败；如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库。git不适合用悲观锁，否则公司倒闭（只能一个人用）。
# 版本号机制
举一个版本号的例子：
数据表存在一个version字段，更新数据时version字段会加1
假设：线程A在读取数据和version(version = 1)的期间，线程B也读取了version(version = 1)
线程A修改数据，更新version(version = 2)，在更新version前读取的version(version = 1)和当前数据表中的version(version = 1)相同，则更新成功
线程B也修改数据，更新version(version = 2)提交更新时，由于读取时version = 1 而当前数据表version = 2 不相等，则更新失败
```sql
select version from table;
update set num=2,version=version+1 where version=1 and id=5;
```
不使用版本号机制：
```sql
select for update
```
# 乐观锁的缺点
## ABA问题
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 "ABA"问题。

JDK 1.5以后的AtomicStampedReference类就提供了此种能力，其中的compareAndSet方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
## 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

目前新版本JVM可以将自旋太久的线程设置为阻塞
## 只能保证一个共享变量的原子操作
CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。
但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。
# 开销对比
+ 悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响【阻塞的优点？】
+ 相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多
<font color="red">疑问：阻塞会释放cpu资源？自旋持有cpu资源？线程唤醒的过程是怎么样的？</font>
# 两种锁各自的使用场景：各有千秋
+ 悲观锁：<font color="red">适合并发写入多的情况</font>，适用于临界区持锁时间比较长的情况，<font color="red">悲观锁可以避免大量的无用自旋等消耗</font>，典型情况：
     1. 临界区有IO操作
     2. 临界区代码复杂或者循环量大
     3. 临界区竞争非常激烈
+ 乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅增高
<font color="red">疑问：读是乐观锁，写是悲观锁的锁</font>
<font color="red">疑问：乐观锁也能写？但是会产生自旋？自旋与cas的关联？</font>

# CAS与Synchronized的使用情景
简单的来说：
+ CAS适用于写比较少的情况下（多读场景，冲突一般较少）
+ Synchronized适用于写比较多的情况下（多写场景，冲突一般较多）

对于资源竞争较少（线程冲突较轻）的情况：
+ 使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源
+ 而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能

对于资源竞争严重（线程冲突严重）的情况：
+ CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized

补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。

