vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/programs/language/java/core/concurrent/JUC/公平锁和非公平锁.md
[TOC]

# 概览
+ 公平指的是按照线程请求的顺序，来分配锁；非公平指的是，不完全按照请求的顺序，在一定情况下，可以插队
+ 注意：非公平也同样不提倡“插队”行为，这里的非公平，指的是“在合适的时机”插队，而不是盲目插队
# 公平和非公平锁
+ 公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。
+ 非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的循序，有可能后申请的线程比先申请的线程优先获取锁。但是，在高并发的情况下，有可能会造成**优先级反转**或者**饥饿现象**。
# 公平锁和非公平锁两者的区别
+ 公平锁：线程按照他们申请锁的顺序获取锁，公平锁就是很公平，在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，如果队列为空，获取当前线程时等待队列的第一个，就占有锁。否则，就会加入到等待队列中，以后会按照FIFO的规则从队列中获取锁。
+ 非公平锁：非公平所比较粗鲁，上来就尝试占有锁，如果尝试失败，就采用类似公平锁的方式获取锁。

补充：ReentrantLock即使通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点就是吞吐量比公平锁大。同样的synchronized也是一种非公平锁。
# 为什么要有非公平锁
+ 为了提高效率，避免唤醒带来的空档期
+ 唤醒的开销很大，在此期间利用空档期提高吞吐量
# 不公平的情况（以ReentrantLock为例）
+ 如果在线程1释放锁的时候，线程5恰好去执行lock()
+ 由于ReentrantLock发现此时并没有线程持有lock这把锁（线程2还没来得及获取到，因为获取需要时间）
+ 线程5可以插队，直接拿到这把锁，这也是ReentrantLock默认的公平策略，也就是“不公平”
# 特例
+ 针对tryLock()方法，它是很猛的，它不遵守设定的公平规则
+ 例如，当有线程执行tryLock()时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他线程现在在等待队列里了
<font color="red">tryLock可以抢写锁吗？</font>
# 对比公平和非公平的优缺点
|          |                           优势                           |                             劣势                             |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 公平锁   | 各线程公平平等，每个线程在等待一段时间后，总有执行的机会 | 更慢，吞吐量更小                                             |
| 非公平锁 | 更快，吞吐量更大                                         | 有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行 |

# 优缺点
非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。

# 使用场景
使用场景的话呢，其实还是和他们的属性一一相关，举个栗子：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁会给业务增强很多的可控制性。
