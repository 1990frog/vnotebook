vnote_backup_file_826537664 /home/cai/Documents/vnote_notebooks/vnotebook/programs/language/java/core/concurrent/JUC/线程池.md
[TOC]

# 什么是池
软件中的池，可以理解为计划经济
如果不使用线程池，每个任务都新开一个线程处理（开销太大）

# 线程的创建和销毁浪费的具体开销

# 为什么要使用线程池
问题1：反复创建线程开销大
用少量的线程——避免内存占用过多
问题2：过多的线程会占用太多内存
让这部分线程都保持工作，且可以反复执行任务——避免生命周期的损耗

# 线程池适合应用的场合
+ 服务器接受到大量请求时，使用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率
+ 实际上，在开发中，如果需要创建5个以上的线程，那么就可以使用线程池来管理

# 线程池构造函数参数
## corePoolSize(int)
核心线程数
## maxPoolSize(int)
最大线程数
## keepAliveTime(long)
保持存活时间
## workQueue(BlockingQueue)
任务存储队列
## threadFactory(ThreadFactory)
当线程池需要新的线程的时候，会使用ThreadFactory来生成新的线程
## Handler(RejectedExecutionHandler)
由于线程无法接受你所提交的任务的拒绝策略

# 参数中的corePoolSize和maxPoolSize
+ corePoolSize指的是核心线程数：线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，再创建新线程去执行任务
+ 线程池也可能会在核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上限，这就是最大量maxPoolSize

# maximumPoolSize
maximumPoolSize和maxPoolSize的含义相同，不做额外区分。实际上，在ThreadPoolExecutor类的参数中，变量名是maximumPoolSize；不过在org.springframework.scheduling.concurrent包的ThreadPoolExecutorFactoryBean类等其他类中，也有使用maxPoolSize作为参数名的情况，我们直接理解为maximumPoolSize和maxPoolSize相同的就可以了

# 添加线程规则
1. 如果线程数小于coolPoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来运行新任务
2. 如果线程数等于（或大于）corePoolSize但少于maximumPoolSize，则将任务放入队列
3. 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务
4. 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务


例子：
烧烤店的桌子，里面的桌子始终存在，外面摆的桌子也是有限的，可以被处理

# 举个例子
线程池：核心池大小为5，最大池大小为10，队列为100
因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程maxPoolSize，最多到10个线程，如果再来任务就拒绝。

# 增减线程的特点
1. 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池
2. 线程池希望保持较少的线程数，并且只有在负债变得很大时才增加它
3. 通过设置maximumPoolSize为很高的值，例如：Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务
4. 是只有队列填满时才创建多于corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize

# keepAliveTime
如果线程池当前的线程数多余corePoolSize，那么如果多余的线程空闲时间超过keepAliveTime，它们就会被终止


# ThreadFactory用来创建线程
+ 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等
+ 通常我们用默认的ThreadFactory就可以了


# 工作队列
有3种最常见的队列类型：
+ 直接交接：SynchronousQueue
+ 无界队列：LinkedBlockingQueue
+ 有界队列：ArrayBlockingQueue

# 线程池应该手动创建还是自动创建
+ 手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险
+ 自动创建的线程池（也就是直接调用JDK封装好的构造函数）可能带来一些问题

# newFixedThreadPool
由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM(OutOfMemoryError)

![](_v_images/20200116212118343_881014309.png)

# newSingleThreadExecutor
可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存

# CachedThreadPool
+ 可缓存线程池
+ 特点：无界线程池，具有自动回收多余线程的功能

![](_v_images/20200116220355459_980452375.png)

# newCachedThreadPool
这里的弊端在于第二个参数maximumPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM

# ScheduledThreadPool
支持定时及周期性任务执行的线程池

![](_v_images/20200116220700873_215850881.png)

# 线程池应该手动创建还是自动创建
正确的创建线程池的方法：根据不同的业务场景，自己设置线程池参数，比如我们的内存有多大，我们想给线程取什么名字等等

# 线程池的线程数量设置为多少比较合适
+ cpu密集型（加密、计算hash等）：最佳线程数为cpu核心数的1-2倍左右
+ 耗时io型（读写数据库、文件、网络读写等）：最佳线程数一般会大于cpu核心数很多倍，以jvm线程监控显示繁忙情况为依据，保证线程空闲可以衔接上，参考Brain Goetz推荐的计算方法：线程数=cpu核心数*(1+平均等待时间/平均工作时间)

FixedThreadPool
![](_v_images/20200116221316932_583829327.png)

CacheThreadPool
![](_v_images/20200116221351540_383895432.png)

# SingleThreadExecutor
+ 单线程的线程池：它只会用唯一的工作线程来执行任务
+ 它的原理和FixedThreadPool是一样的，但是此时的线程数量被设置为了1

![](_v_images/20200116221629170_2011107887.png)

# ScheduledThreadPool来说，它使用的是延迟队列DelayedWorkQueue

# workStealingPool是jdk1.8加入的
+ 这个线程池和之前的都有很大不同
+ 子任务
+ 窃取

不保障顺序，如果任务是递归的，会产生子任务适合这种线程池