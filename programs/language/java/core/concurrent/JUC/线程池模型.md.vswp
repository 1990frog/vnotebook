vnote_backup_file_826537664 /home/cai/Documents/vnotebook/programs/language/java/core/concurrent/JUC/线程池模型.md
[TOC]

# 常用线程池构造参数
|   Parameter   |   FixedThreadPool    | CachedThreadPool  | ScheduledThreadPool |   SingleThreaded    |
| ------------- | -------------------- | ----------------- | ------------------- | ------------------- |
| corePoolSize  | constructor-arg      | 0                 | contructor-arg      | 1                   |
| maxPoolSize   | same as corePoolSize | Integer.MAX_VALUE | Integer.MAX_VALUE   | 1                   |
| keepAliveTime | 0 seconds            | 60 seconds        | 0 seconds           | 0 seconds           |
| workQueue     | LinkedBlockingQueue  | SynchronousQueue  | DelayedWorkQueue    | LinkedBlockingQueue |

# newFixedThreadPool：定长线程池，queue无容量限制
## 参数
+ corePoolSize：自定义
+ maxPoolSize：自定义
+ keepAliveTime：不设置
+ workQueue：LinkedBlockingQueue无界队列

## 源码
```java
/**
 * Creates a thread pool that reuses a fixed number of threads
 * operating off a shared unbounded queue.  At any point, at most
 * {@code nThreads} threads will be active processing tasks.
 * If additional tasks are submitted when all threads are active,
 * they will wait in the queue until a thread is available.
 * If any thread terminates due to a failure during execution
 * prior to shutdown, a new one will take its place if needed to
 * execute subsequent tasks.  The threads in the pool will exist
 * until it is explicitly {@link ExecutorService#shutdown shutdown}.
 *
 * @param nThreads the number of threads in the pool
 * @return the newly created thread pool
 * @throws IllegalArgumentException if {@code nThreads <= 0}
 */
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

## 注意
由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法及时处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM(OutOfMemoryError)
测试：
```
设置VM options: -Xmx8m -Xms8m
```

# newSingleThreadExecutor：单线程池，queu无容量限制
+ 单线程的线程池：它只会用唯一的工作线程来执行任务
+ 它的原理和FixedThreadPool是一样的，但是此时的线程数量被设置为了1

## 参数
+ corePoolSize：1
+ maxPoolSize：1
+ keepAliveTime：不设置
+ workQueue：LinkedBlockingQueue无界队列

## 源码
```java
/**
 * Creates an Executor that uses a single worker thread operating
 * off an unbounded queue. (Note however that if this single
 * thread terminates due to a failure during execution prior to
 * shutdown, a new one will take its place if needed to execute
 * subsequent tasks.)  Tasks are guaranteed to execute
 * sequentially, and no more than one task will be active at any
 * given time. Unlike the otherwise equivalent
 * {@code newFixedThreadPool(1)} the returned executor is
 * guaranteed not to be reconfigurable to use additional threads.
 *
 * @return the newly created single-threaded Executor
 */
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

## 注意
可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同样的问题，也就是当请求堆积的时候，可能会占用大量的内存

# CachedThreadPool：可缓存线程池，无界线程池，自带回收机制
没有线程容量的限制，当分配新任务就会创建一个新的线程，超过 keepAliveTime 60s还没有新的任务，过期自动销毁多余线程池
## 参数
+ corePoolSize：0
+ maxPoolSize：Integer.MAX_VALUE
+ keepAliveTime：60秒
+ workQueue：SynchronousQueue零容量，立即交换队列

## 源码
```java
/**
 * Creates a thread pool that creates new threads as needed, but
 * will reuse previously constructed threads when they are
 * available.  These pools will typically improve the performance
 * of programs that execute many short-lived asynchronous tasks.
 * Calls to {@code execute} will reuse previously constructed
 * threads if available. If no existing thread is available, a new
 * thread will be created and added to the pool. Threads that have
 * not been used for sixty seconds are terminated and removed from
 * the cache. Thus, a pool that remains idle for long enough will
 * not consume any resources. Note that pools with similar
 * properties but different details (for example, timeout parameters)
 * may be created using {@link ThreadPoolExecutor} constructors.
 *
 * @return the newly created thread pool
 */
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>(),
                                  threadFactory);
}
```

## 注意
+ 可缓存线程池
+ 无界线程池，具有自动回收多余线程的功能（60s就挂了）
+ 这里的弊端在于第二个参数maximumPoolSize被设置为Integer.MAX_VALUE，这可能会创建数量非常多的线程，甚至导致OOM

# ScheduledThreadPool
支持定时及周期性任务执行的线程池

## 参数
+ command：Runnable
+ initialDelay：延迟首次执行的时间
+ period：两次执行之间的时间间隔
+ unit：时间单位

## 源码
```java
/**
 * Creates a thread pool that can schedule commands to run after a
 * given delay, or to execute periodically.
 * @param corePoolSize the number of threads to keep in the pool,
 * even if they are idle
 * @return a newly created scheduled thread pool
 * @throws IllegalArgumentException if {@code corePoolSize < 0}
 */
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
```
ScheduledExecutorService.java
```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());
}
```

## workStealingPool是jdk1.8加入的（有点难哦ForkJoinPool）
+ 这个线程池和之前的都有很大不同
+ 子任务
+ 窃取

不保障顺序，如果任务是递归的，会产生子任务适合这种线程池