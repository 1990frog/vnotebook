vnote_backup_file_826537664 /home/cai/Documents/vnotebook/programs/language/java/core/concurrent/JUC/悲观锁与乐观锁.md
[TOC]

# 概览
【悲观锁】又名【互斥同步锁】
【乐观锁】又名【非互斥同步锁】

cas对比monitor
悲观锁：select for update就是悲观锁
乐观锁：用version控制数据库就是乐观锁
添加一个字段lcok_version
先查询这个更新语句的version：select * from table
然后update set num=2,version=version+1 where version=1 and id=5;
如果version被更新了等于2，不一样就会更新出错，这就是乐观锁的原理
# 悲观锁的劣势
+ 阻塞和唤醒带来的性能劣势（开销大）
+ 永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行（synchronized不能被中断，那其他的呢？）
+ 优先级反转（优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证）
# 悲观锁：Synchronized与Lock拓展类
+ 如果我不锁住这个资源，别人就回来争抢，就会造成数据结果错误，所以每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失
+ <font color="red">**Java中的悲观锁的实现就是synchronized和Lock相关类**</font>
# 乐观锁：Atomic原子类、并发容器
+ 如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略
+ 乐观锁的实现一般都是利用CAS算法来实现的
## 举栗
1. 线程1发现没人在计算期间修改资源，于是把自己的计算结果写到资源里
2. 线程2计算完并判断资源是否已被修改，发现计算期间有人修改了资源，于是报错或重试
## 再举栗
Git就是乐观锁的典型例子，当我们往远端仓库push的时候，git会检查远端仓库版本是不是领先于我们现在的版本，如果远程仓库的版本号和本地的不一样，就表示有其他人修改了远端代码了，我们的这次提交就失败；如果远端和本地版本号一致，我们就可以顺利提交版本到远端仓库
。git不适合用悲观锁，否则公司倒闭（只能一个人用）。
# 开销对比
+ 悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响【阻塞的优点？】
+ 相反，虽然乐观锁一开始的开销比悲观锁小，但是如果自旋时间很长或者不停重试，那么消耗的资源也会越来越多
<font color="red">疑问：乐观锁不会阻塞（jvm操作另说）</font>
<font color="red">疑问：悲观锁是写锁，读锁呢？</font>
<font color="red">疑问：阻塞会释放cpu资源？自旋持有cpu资源？线程唤醒的过程是怎么样的？</font>
# 两种锁各自的使用场景：各有千秋
+ 悲观锁：<font color="red">适合并发写入多的情况</font>，适用于临界区持锁时间比较长的情况，<font color="red">悲观锁可以避免大量的无用自旋等消耗</font>，典型情况：
     1. 临界区有IO操作
     2. 临界区代码复杂或者循环量大
     3. 临界区竞争非常激烈
+ 乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅增高
<font color="red">疑问：读是乐观锁，写是悲观锁的锁</font>
<font color="red">疑问：乐观锁也能写？但是会产生自旋？自旋与cas的关联？</font>