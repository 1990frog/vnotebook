[TOC]

# 并发容器概览
+ ConcurrentHashMap：线程安全的HashMap
+ CopyOnWriteArrayList：线程安全的List
+ BlockingQueue：这是一个接口，表示阻塞队列，非常适合用于作为数据共享的通道
+ ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看做一个线程安全的LinkedList
+ ConcurrentSkipListMap：是一个Map，使用跳表的数据结构进行快速查找

# Vector和Hashtable（线程安全）
大量使用Synchronized，性能差

# ArrayList和HashMap
虽然这两个类不是线程安全的，但是可以用
Collection.synchronizedList(new ArrayList<E>())和Collection.synchronizedMap(new HashMap<K,V>())
使之变成线程安全的
同步代码块封装

# ConcurrentHashMap和CopyOnWriteArrayList
+ 取代同步的HashMap和同步的ArrayList（时代巨轮滚滚向前）
+ 绝大多数并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能都更好（CopyOnWriteArrayList写多情况除外，Collection.synchronizedList更适合写多。而ConcurrentHashMap任何情景之下都强于其他方法）

# Map简介
+ HashMap
+ Hashtable
+ LinkedHashMap
+ TreeMap

![](_v_images/20200124105531252_1991651094.png)

# 为什么HashMap是线程不安全的
## 同时put碰撞导致数据丢失
多线程put，计算的hash值是一样的，会将所有的数据放到一个位置，就会造成其余数据丢失
## 同时put扩容导致数据丢失
多个并发扩容，只有一个扩容之后的数组会被保留下来
## 死循环造成的cpu100%
![](_v_images/20200125120102146_1613230470.png)


![](_v_images/20200125120431365_1583465915.png)

![](_v_images/20200125120458227_1694279781.png)

![](_v_images/20200125120531162_127120047.png)

![](_v_images/20200125120642241_1907884811.png)

![](_v_images/20200125120719158_1741685120.png)

![](_v_images/20200125120858259_152219583.png)