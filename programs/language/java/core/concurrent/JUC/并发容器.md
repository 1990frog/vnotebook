[TOC]

# 并发容器概览
+ ConcurrentHashMap：线程安全的HashMap
+ CopyOnWriteArrayList：线程安全的List
+ BlockingQueue：这是一个接口，表示阻塞队列，非常适合用于作为数据共享的通道
+ ConcurrentLinkedQueue：高效的非阻塞并发队列，使用链表实现。可以看做一个线程安全的LinkedList
+ ConcurrentSkipListMap：是一个Map，使用跳表的数据结构进行快速查找

# Vector和Hashtable（线程安全）
大量使用Synchronized，性能差

# ArrayList和HashMap
虽然这两个类不是线程安全的，但是可以用
Collection.synchronizedList(new ArrayList<E>())和Collection.synchronizedMap(new HashMap<K,V>())
使之变成线程安全的
同步代码块封装

# ConcurrentHashMap和CopyOnWriteArrayList
+ 取代同步的HashMap和同步的ArrayList（时代巨轮滚滚向前）
+ 绝大多数并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能都更好（CopyOnWriteArrayList写多情况除外，Collection.synchronizedList更适合写多。而ConcurrentHashMap任何情景之下都强于其他方法）

# Map简介
+ HashMap
+ Hashtable
+ LinkedHashMap
+ TreeMap

![](_v_images/20200124105531252_1991651094.png)

# 为什么HashMap是线程不安全的
## 同时put碰撞导致数据丢失
多线程put，计算的hash值是一样的，会将所有的数据放到一个位置，就会造成其余数据丢失
## 同时put扩容导致数据丢失
多个并发扩容，只有一个扩容之后的数组会被保留下来
## 死循环造成的cpu100%
![](_v_images/20200125120102146_1613230470.png)


![](_v_images/20200125120431365_1583465915.png)

![](_v_images/20200125120458227_1694279781.png)

![](_v_images/20200125120531162_127120047.png)

![](_v_images/20200125120642241_1907884811.png)

![](_v_images/20200125120719158_1741685120.png)

![](_v_images/20200125120858259_152219583.png)

![](_v_images/20200125165253070_1774560434.png)

![](_v_images/20200125165401108_784324702.png)

![](_v_images/20200126105245540_890641228.png)

![](_v_images/20200126105334280_1046099406.png)

![](_v_images/20200126105630770_344098653.png)

![](_v_images/20200126105817501_92599600.png)
默认是链表的形式，因为它占用的内存更少

# 错误使用造成线程不安全

![](_v_images/20200126110629362_1543316772.png)

在hashmap中多个线程同时put会造成结果不可预知

上述的代码使用hashmap也是安全的

![](_v_images/20200126111131847_1217498538.png)

![](_v_images/20200126111339130_1273739550.png)

![](_v_images/20200126111802976_1623623554.png)


# CopyOnWriteArrayList
+ 代替Vector和SynchronizedList，就和ConcurrentHashMap代替SynchronizedMap的原因一样
+ Vector和SynchronizedList的锁的粒度太大，并发效率相对比较低，并且迭代时无法编辑
+ Copy-On-Write并发容器还包括CopyOnWriteArraySet，用来替代同步Set

# CopyOnWriteArrayList适用场景
+ 读操作可以尽可能地快，而写操作即使慢一些也没有太大关系
+ 读多写少：黑名单，每日更新；监听器：迭代操作远多余修改操作

# CopyOnWriteArrayList读写规则
+ 回顾读写锁：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）
+ 读写锁规则的升级：读取是完全不用加锁的，并且更厉害的是写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待

![](_v_images/20200129145138440_1452252089.png)
hashmap不能在迭代的时候修改

![](_v_images/20200129145244852_409166032.png)
CopyOnWriteArrayList可以在迭代中修改


# CopyOnWriteArrayList实现原理
+ CopyOnWrite的含义
+ 创建新副本、读写分离
+ “不可变”原理
+ 迭代的时候（依然使用旧数组不报错）

![](_v_images/20200129150301101_710854899.png)

![](_v_images/20200129150349992_1345448040.png)
modCount修改的次数

![](_v_images/20200129152302374_837513938.png)

迭代出现数据过期的问题

# CopyOnWriteArrayList的缺点
+ 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的数据，马上能读到，请不要使用CopyOnWrite容器
+ 内存占用问题：因为CopyOnWrite的写是复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存


![](_v_images/20200129153430071_124661264.png)

# 并发队列Queue
阻塞队列
非阻塞队列

# 为什么要使用队列
+ 用队列可以在线程间传递数据：生产者消费者模式、银行转账
+ 考虑锁等线程安全问题的重任从“你”转移到了“队列”上

# 并发队列简介
+ Queue
+ BlockingQUeue

部分：
![](_v_images/20200129154302703_1648858905.png)

# 什么是阻塞队列
+ 阻塞队列是具有阻塞功能的队列，所以它首先是一个队列，其次是具有阻塞功能
+ 通常，阻塞队列的一端是给生产者放数据用，另一端给消费者拿数据用。阻塞队列是线程安全的，所以生产者和消费者都可以是多线程的
+ take()方法：获取并移除队列的头结点，一旦如果执行take的时候，队列里无数据，则阻塞，直到队列里有数据
+ put()方法：插入元素。但是如果队列已满，那么就无法继续插入，则阻塞，知道队列里有了空闲空间
+ 是否有界（容量有多大）：这是一个非常重要的属性，无界队列意味着里面可以容纳非常多（Integer.MAX_VALUE，约为2的31次，是非常大的一个数，可以近似认为是无限容量）
+ 阻塞队列和线程池的关系：阻塞队列是线程池的重要组成部分

# BlockingQueue主要方法
+ put
+ take
+ add
+ remove
+ element
+ offer
+ poll
+ peek

# ArrayBlockingQueue
+ 有界
+ 指定容量
+ 公平：还可以指定是否要保证公平，如果想保证公平的话，那么等待了最长时间的线程会被优先处理，不过这会同时带来一定的性能消耗

![](_v_images/20200130105014859_1220152153.png)

# LinkedBlockingQueue
+ 无界
+ 容量Integer.MAX_VALUE
+ 内部结构：Node、两把锁。分析put方法

# PriorityBlockingQueue
+ 支持优先级
+ 自然顺序（而不是先进先出）
+ 无界队列
+ PriorityQueue的线程安全版本

# SynchronousQueue
+ 它的容量为0
+ 需要注意的是，SynchronousQueue的容量不是1而是0，因为SynchronousQueue不需要去持有元素，它所做的就是直接传递（direct handoff）
+ 效率很高
+ SynchronousQueue没有peek等函数，因为peek的含义是取出头结点，但是SynchronousQueue的容量是0，所以连头结点都没有，也就没有peek方法。同理，没有iterate相关方法
+ 是一个极好的用来直接传递的并发数据结构
+ SynchronousQueue是线程池Executors.newCachedThreadPool()使用的阻塞队列

# DelayQueue
+ 延迟队列，根据延迟时间排序
+ 元素需要实现Delayed接口，规定排序规则

# 非阻塞并发队列
+ 并发包中的非阻塞队列只有ConcurrentLinkedQueue这一种，顾名思义ConcurrentLinkedQueue是使用链表作为其数据结构的，使用CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景。用到相对比较少一些
+ 看源码的offer方法的CAS思想，内有p.casNext方法，用了UNSAFE.compareAndSwapObject

# 如何选择适合自己的队列
+ 边界
+ 空间
+ 吞吐量

# 并发容器总结
java.util.concurrent包提供的容器，分为3类：Concurrent*、CopyOnWrite*、Blocking*
Concurrent*的特点是大部分通过CAS实现并发、而CopyOnWrite*则是通过复制一份原数据来实现的、Blocking通过AQS实现的
