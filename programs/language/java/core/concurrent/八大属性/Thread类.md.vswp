vnote_backup_file_826537664 /home/cai/Documents/vnotebook/programs/language/java/core/concurrent/八大属性/Thread类.md
[TOC]

# 概览
Thread是线程本身，启动线程调用Thread的start方法，其由native方法底层实现（启动新线程），如果直接调用run方法，等同在主线程中调用方法<font color="red">（非异步）</font>。

# run()
# start()方法
<font color="red">Thread.start()不能被调用两次，该方法会记录是否被调用，如果已被调用就抛出错误。</font>
## 代码
```java
class Thread implements Runnable{
    ...
    public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)//调用两次start报错原因
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 t）hrew a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
    ...
}
/**
 *run方法，其持有一个Runnable对象，如果直接继承Thread会重写run方法
 */
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```
## start执行流程
1. 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException
2. 被加入线程组
3. 调用start()方法启动线程
注意点：
1. start方法是被synchronized修饰的方法，可以确保线程安全
2. 由JVM创建的main方法线程和system组线程，并不会通过start来启动
# currentThread()方法
## 代码
这是个native方法
```java
class Thread{
    public static native Thread currentThread();
}
```
## 注意
静态方法，所以使用Thread.currentThread()的方式调用
# interrupt()方法
这个方法只是修改中断状态，并不会像stop一样直接干掉线程，而是优雅的通知，这个方法调用之后在触发InterruptException之后会被重置为fasle。
```java
public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();

    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // Just to set the interrupt flag
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}
```
# interrupted()方法

# isInterrupted()方法

# join()方法

# setDaemon()方法


# yield()
# setPriority()

# isAlive()

# sleep()


# suspond()方法
# stop()方法
# destroy()方法