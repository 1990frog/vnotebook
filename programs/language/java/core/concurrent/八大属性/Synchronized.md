[TOC]

# 待学习
synchronized与notify与wait
# 关键字
互斥同步锁、happen-before、原子性、可见性、可重入、执行完毕自动释放锁（Lock不会）

synchronized关键字不能被多态继承。如果父类中的某个方法是synchronized的，而子类中覆盖了这个方法，那么默认情况下子类中的这个方法并不是synchronized的，必须显式的在子类的这个方法中加上synchronized关键字才行。当然，不覆盖的话没事。不过子类的那个方法也可以通过调用父类中该相应的方法来实现synchronized效果。
# Synchronized的作用
JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以执行指定代码，从而保证了线程安全，同时具有**可重入**和**不可中断**的性质。能保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。
# Synchronized的地位
+ Synchronizde是Java的关键字，被Java语言原生支持
+ 是最基本的互斥同步手段
+ 是并发编程中的元老级角色，是并发编程的必学内容
# synchronized的缺陷
1. 效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程
释放锁情况：执行完毕、触发异常
Lock可以设置超时时间、可以中断
2. 不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个所仅有单一的条件（某个对象），可能是不够的
3. 无法知道是否成功获取到锁
# 并发中不使用Synchronized可能会有什么后果？
例子：i++
原因：
count++，它看上去只是一个操作，实际上包含了三个动作：
1. 读count
2. 将count加1
3. 将count的值写入到内存中
其他实现方式：AtomicInteger原子类、volatile（不可以，因为其只保障可见性）
# Synchronized的两种用法
+ 对象锁
+ 类锁

区别：锁对象是否为class对象
# 对象锁
概念：使用Object对象及其子类作为锁
本质：非Class对象作为锁
形式1：非静态方法（该类的实例为锁）
形式2：synchronized代码块中，指定其锁（非class对象），或使用this
# 类锁
概念（重要） ：Java类可能有很多个对象，但只有一个Class对象（一个类只有一个class对象）
本质：所以所谓的类锁，不过是Class对象的锁而已。
形式1：synchronized加在static方法上
形式2：synchronized（*.class）代码块
# 多线程访问同步方法的7种情况
## 情况1：两个线程同时访问一个对象的同步方法（同一把锁）
```java

```
## 情况2：两个线程访问的是两个对象的同步方法（两把不同的锁）
```java

```
## 情况3：两个线程访问的是synchronized的静态方法（同一把锁：类锁）
```java

```
## 情况4：同时访问同步方法与非同步方法（非同步方法不受到影响）
```java

```
## 情况5：访问同一个对象的不同的普通同步方法（同一把锁，串行）
```java

```
## 情况6：同时访问静态synchronized和非静态synchronized方法（两把锁，一把对象锁、一把类锁）
```java

```
## 情况7：方法抛出异常后，会释放锁（Lock不会释放锁，synchronized会）
```java

```

# 7种情况总结：3点核心思想
1. 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1、5种情况）；
2. 每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把类锁（对象第2、3、4、6种情况）；
3. 无论方法是正常执行完毕或者方法抛出异常，都会释放锁（对应第7种）

# 在Synchronized方法中调用非Synchronized方法，是线程安全的吗？
不是，非Synchronized方法，可以被多个线程同时访问，所以不是线程安全的（除非入口是在Synchronized方法中）

# synchronized性质
+ 阻塞锁
+ 排它锁
+ 非公平锁
+ 可重入锁（递归锁）
+ 不可中断锁

## 什么是可重入
指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁
### 好处
避免死锁、提升封装性
### 粒度
线程范围而非调用层面
### 举例
买车上牌需要摇号，如果摇到了号可以给车上牌照，如果家里有多台车，摇不可能摇到一次就给三台车都上牌。这就是不可重入性；如果摇到一个号就可以一直的获取拍照，就是可重入。
### 原理
JVM负责跟踪对象被加锁的次数
线程第一次给对象加锁的时候，计数变为1.每当这个相同的线程在此对象上再次获得锁时，计数会递增
每当任务离开时，计数递减，当计数为0的时候，锁被完全释放
# 不可中断
一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，知道别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远地等下去。

相比之下，未来会介绍Lock类，可以拥有中断的能力
1. 如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行
2. 如果我觉得我等待的时间太长了不想再等了，也可以退出

# 常见面试题
## 使用注意点
锁对象不能为空、作用域不宜过大、避免死锁
## 如何选择Lock和synchronized关键字？
如果可以的话，既不要使用synchronized也不用使用lock而是使用JUC包中各色各样的类，使用这些类不需要自己做同步工作，更方便也更不易出错。如果只在两者中选，那就选synchronized，因为其会自动释放锁、减少代码少。如果需要灵活的加解锁机制，那就选lock。

# 思考
1. 多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的是哪个线程？
2. Synchronized使得同时只有一个线程可以执行，性能较差，有什么办法可以提升性能？
3. 我想更灵活地控制锁的获取和释放（现在释放锁的时机都被规定死了），怎么办？
4. 什么是锁的升级、降级？什么是JVM里的偏斜所、轻量级锁、重量级锁？