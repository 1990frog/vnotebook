vnote_backup_file_826537664 /home/cai/Documents/vnotebook/programs/language/java/core/concurrent/八大属性/停止线程.md
[TOC]

<font color="red">是否可以这样理解：java的线程中断，基于异常管理？【利用到异常，但是仅是改变中断状态】</font>
# 什么情况需要中断线程？
+ 线程发生阻塞长时间运行（最好的处理方式：超时时间，或者守护线程发起中断）
+ IO发生阻塞，例如磁盘不够
# Java中停止线程的原则
+ <font color="red">在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止的线程自身拥有决定权（决定是否、以及何时停止），这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。</font>
+ 任务和线程的启动很容易。在大多数时候,我们都会让它们运行直到结束,或者让它们自行停止。然而,有时候我们希望提前结束任务或线程,或许是因为用户取消了操作,或者服务需要被快速关闭，或者是运行超时或出错了。
+ 要使任务和线程能安全、快速、可靠地停止下来,并不是一件容易的事。<font color="red">Java没有提供任何机制来安全地终止线程。</font>但它提供了中断(Interruption),这是一种协作机制,能够使一个线程终止另一个线程的当前工作。
+ 这种协作式的方法是必要的，<font color="red">我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。（核心是保护数据）</font>相反,在编写任务和服务时可以使用一种协作的方式:当需要停止时,它们首先会清除当前正在执行的工作,然后再结束。这提供了更好的灵活性,因为任务本身的代码比发出取消请求的代码更清楚如何执行清除工作。
+ 生命周期结束(End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂,而这个在程序设计中非常重要的要素却经常被忽略。一个在行为良好的软件与勉强运的软件之间的最主要区别就是,行为良好的软件能很完善地处理失败、关闭和取消等过程。
# 为什么要用interrupt()方法来停止线程
+ interrupt()方法只是改变线程状态，而不是强制关闭线程
+ 被中断的线程它本身拥有响应中断的权利，因为有些线程的某些代码是非常重要的，我们必须要等待这些线程处理完成之后或者他们准备好之后，再由他们自己去主动终止，或者它们真的不想理会我们的中断这也是完全ok的，我们不应该鲁莽的使用stop方法，而是通过使用interrupt方法来发出一个信号，由它们自己处理，这样使我们的线程代码，在实际中更加安全，也完成了清理工作，数据的完整性也得到了保障
# 两种中断机制
1. 传递中断
2. 恢复中断状态
# 传递中断（优先选择）
<font color="red">添加异常到方法签名，在方法上抛出异常。</font>
用`throws InterruptedException`标记你的方法，不采用`try-catch`语句块捕获异常，以便于该异常可以传递到顶层，让顶层方法如`run`方法可以捕获这一异常
例如：
```java
void subTask() throws InterruptedException
    sleep(delay);
}
```
## 恢复中断状态（不得已而为止）
+ <font color="red">如果说接口的方法签名未抛出异常，那么实现该接口的方法就不能向上抛出异常</font>
+ 为了应对不能传递中断的情况（某些抽象方法体上未添加方法签名），我们就用向上抛出异常
+ 使用**Thread.currentThread().interrupt()**来恢复线程中断状态（注：被捕获之后状态会被重置）

在下面代码中：如果sleep被中断，就会触发`InterruptedException`，根据java的线程中断机制interruptStatus将会被重置。
如果没有throw异常将会被catch吞掉。所以重新将中断状态设置为中断，交由上层调用检查
```java
/**
 * 描述
 * 最佳实践2：
 * 在catch子语句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行中，
 * 依然能够检查到刚才发生了中断回到刚才RightWayStopThreadInProd补上中断，让它跳出
 */
public class RightWayStopThreadInProd2 implements Runnable {

    @Override
    public void run() {
        while (true) {
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Interrupted，程序运行结束");
                break;
            }
            reInterrupt();
        }
    }

    private void reInterrupt() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {//InterruptException被catch捕获之后，清空interrupted状态
            Thread.currentThread().interrupt();//在此重新恢复interruptd状态
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new RightWayStopThreadInProd2());
        thread.start();
        Thread.sleep(1000);
        thread.interrupt();
    }
}
```
# InterruptedException异常，这不是个错误，而是一个标记
if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown
interrupt方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。
## 实现中断
Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception. The following code can be used to achieve this effect:
```java
if (Thread.interrupted())  // Clears interrupted status!
  throw new InterruptedException();
```
如果抛出`InterruptedException`意味着一个方法是阻塞方法（java默认的会造成wait，time_wait状态的方法都声明支持interrupt），那么调用一个阻塞方法则意味着您的方法也是一个阻塞方法（强制你方法签名上抛出`InterruptedException`异常），而且您应该有某种策略来处理`InterruptedException。`
## 为何重置状态
分为两步看：
1. 触发中断之前（浪）
2. 触发中断之后（善后）

具体原因：
+ <font color="red">线程中断仅仅是设置线程的中断状态位，不会停止线程。所以当一个线程处于中断状态时，如果再由wait、sleep以及jion三个方法引起的阻塞，那么JVM会将线程的中断标志重新设置为false，并抛出一个InterruptedException异常，然后开发人员可以中断状态位“的本质作用—–就是程序员根据try-catch功能块捕捉jvm抛出的InterruptedException异常来做各种处理，比如如何退出线程。总之interrupt的作用就是需要用户自己去监视线程的状态位并做处理。”</font>
+ <font color="red">如果不清空中断状态，那么在catch、或对应的处理中断的代码中，如果再次发生了阻塞，那就无法处理（核心概念就是java的interrupt不是stop，而是一种协作机制）</font>
+ interrupt()是用来设置中断状态的。返回true说明中断状态被设置了而不是被清除了。我们调用sleep、wait等此类可中断（throw InterruptedException）方法时，一旦方法抛出InterruptedException，当前调用该方法的线程的中断状态就会被jvm自动清除了，就是说我们调用该线程的isInterrupted方法时是返回false。如果你想保持中断状态，可以再次调用interrupt方法设置中断状态。<font color="red">※这样做的原因是，java的中断并不是真正的中断线程，而只设置标志位（中断位）来通知用户。如果你捕获到中断异常，说明当前线程已经被中断，不需要继续保持中断位。（线程已经被中断，但是响应中断的对应的善后工作没被中断，要执行的）</font>

总结：
可以理解为软删除，将数据状态设置为失效，但是在数据空间中还是存在

# 不可中断的阻塞方法
## <font color="red">无响应机制？</font>
并非所有的阻塞方法都抛出 InterruptedException。输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会提前返回。然而，对于套接字 I/O，如果一个线程关闭套接字，则那个套接字上的阻塞 I/O 操作将提前结束，并抛出一个 SocketException。java.nio 中的非阻塞 I/O 类也不支持可中断 I/O，但是同样可以通过关闭通道或者请求 Selector 上的唤醒来取消阻塞操作。类似地，尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式。

<font color="red">并不是所有的阻塞都是可中断的, 比如InputStream.read方法. 在检测到输入数据可用, 到达流末尾或者抛出异常前, 该方法一直阻塞. 而且阻塞的时候不会检查中断标记, 所以中断线程无法使read从阻塞状态返回. 但是关闭流可以使得read方法抛出异常, 从而从阻塞状态返回。</font>

例如：
```java
ServerSocket serverSocket = new ServerSocket(PORT);
Socket socket = serverSocket.accept();//阻塞函数
```
Socker.accept()一直在监听端口，一直阻塞在此处。他本身无法响应中断，如果启动一个守护线程来关闭也是可以的：硬关闭，socket.close()

一个情景（伪代码）：
```
method(){
    loop(true){//一直阻塞在此处，永远都走不到下面要执行响应中断的代码
        request()
    }
    while(isInterrupted){
        interrupt()
    }
}
```
# 互斥锁不可被中断
## synchronized

```java
public class CantInterruptSynchronized {

    static Object obj = new Object();

    public static void main(String[] args) {

        Runnable runnable = ()->{//lumbda创建对象依赖并受限于抽象函数接口
            synchronized (obj){
                System.out.println(Thread.currentThread().getName()+":拿到锁");
                for(;;){
                    System.out.println(Thread.currentThread().isInterrupted());
                }
            }
        };

        Thread thread1 = new Thread(runnable);
        thread1.setName("thread1");
        thread1.start();

        thread1.interrupt();

        Thread thread2 = new Thread(runnable);
        thread2.setName("thread2");
        thread2.start();

    }
}
```
## lock
lock也不行

# 不可取消的任务
<font color="red">有些任务拒绝被中断，这使得它们是不可取消的。</font>但是，即使是不可取消的任务也应该尝试保留中断状态，以防在不可取消的任务结束之后，调用栈上更高层的代码需要对中断进行处理。下列代码展示了一个方法，该方法等待一个阻塞队列，直到队列中出现一个可用项目，而不管它是否被中断。为了方便他人，它在结束后在一个 finally 块中恢复中断状态，以免剥夺中断请求的调用者的权利。（它不能在更早的时候恢复中断状态，因为那将导致无限循环 —— BlockingQueue.take() 将在入口处立即轮询中断状态，并且，如果发现中断状态集，就会抛出 InterruptedException。）

例子：
队列栈头位置的请求一直处理失败，后面的数据都会被栈头位置数据阻塞无法得到执行，造成饥饿（准不准？）

```java
public Task getNextTask(BlockingQueue<Task> queue) {
    boolean interrupted = false;
    try {
        while (true) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                interrupted = true;
                // fall through and retry
            }
        }
    } finally {
        if (interrupted)
            Thread.currentThread().interrupt();
    }
}
```
# 尝试中断不可被中断的方法（包括长时间运行的方法、阻塞io）
## 方法一：设置超时时间
```java
public void method(){
    thread.start();
    join(time){
        print("老子不等了")
    }
}
```
## 方法二：设置守护线程
```java
public void main(){
    thread1.start();
    thread2.setMain(thread1);
    thread2.start();
}
thread1{
    run();
}
thread2{
    if(thread1.isinterrupted)
        thread.close()//这有点问题哈，如果线程是可中断的阻塞，那就没必要用，如果线程是bio类的，那么close；
}
```
# interrupted
+ Thread.interrupted()：返回当前线程中断状态后重置中断状态（Thread类静态方法，作用对象为调用该方法的线程）

```java
/**
 * 描述：
 * 注意Thread.interrupted()方法的目标对象是“当前线程”，而不管本方法来自于哪个对象
 * 可将Thread看成this类似
 */
public class RightWayInterrupted {

    /**
     * output:
     * isInterrupted: true
     * isInterrupted: false
     * isInterrupted: false
     * isInterrupted: true
     *
     * Thread.interrupted()方法调用，只作用于当前线程：
     * public static boolean interrupted() {
     *      return currentThread().isInterrupted(true);
     * }
     */
    public static void main(String[] args) throws InterruptedException {

        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                for (; ; ) {
//                    if(Thread.currentThread().isInterrupted()){
//                        break;
//                        Thread.interrupted();
//                    }
                }
            }
        });

        // 启动线程
        threadOne.start();
        //设置中断标志
        threadOne.interrupt();//threadOne is true
        //获取中断标志,threadOne被中断：ture
        System.out.println("isInterrupted: " + threadOne.isInterrupted());//threadOne is true
        //获取中断标志并重置，main的中断状态被重置：false
        System.out.println("isInterrupted: " + threadOne.interrupted());//main is false
        //获取中断标志并重置，main的中断状态被重置：false
        System.out.println("isInterrupted: " + Thread.interrupted());//main is false
        //获取中断标志,threadOne的中断状态：ture
        System.out.println("isInterrupted: " + threadOne.isInterrupted());//threadOne is true
        threadOne.join();
        System.out.println("Main thread is over.");
    }
}
```
## interrupted为啥仅作用于当前的线程
interrupted()是静态方法（类方法），并且调用了currentThread()【返回当前线程的实例】

```java
public class Thread implements Runnable{

    /**
     * Returns a reference to the currently executing thread object.
     *
     * @return  the currently executing thread.
     */
    @NotNull @Contract(pure=true) public static native Thread currentThread();

    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
    ......
    @NotNull @Contract(pure=true) public boolean isInterrupted() {
        return isInterrupted(false);
    }
}
```
## isInterrupted
+ obj_thread.isInterrupted()：返回调用该方法的线程的中断状态
```java
public class Thread implements Runnable{
    ...
    @NotNull @Contract(pure=true) public boolean isInterrupted() {
        return isInterrupted(false);
    }
}
```
# Thread与Object
使用synchronized时，锁对象一般使用Object。调用obj.wait，obj.notify，obj.notifyAll比较方便
<font color="red">java使用Object对象做锁</font>
<font color="red">Thread.wait()可能会造成问题？？？？？？</font>
# volatile标记中断状态的局限性
volatile变量标记的状态位发生变化不会立刻获取到中断请求，具体要看业务，如果已经进入到了执行方法内，此时发生中断，任务仍允许执行完毕，那就可以。反之，则中断无效

<font color="red">在中断检测之前或之后发生阻塞，走不到响应阻塞处理的代码</font>

<font color="red">“中断操作”作用于非阻塞方法，没啥意义，要的是如果阻塞了，可以通过某种机制响应中断，类似sleep这种都是一种即时处理</font>

```java
/**
 * 描述：
 * 演示用volatile的局限：part1 看似可行,实则不行
 */
public class WrongWayVolatile implements Runnable {

    private volatile boolean canceled = false;

    @Override
    public void run() {
        int num = 0;
        try {
            while (num <= 100000 && !canceled) {
                if (num % 100 == 0) {
                    System.out.println(num + "是100的倍数。");
                }
                num++;
                Thread.sleep(1);//阻塞时间短，不会发生在阻塞期间更改中断状态
//                Thread.sleep(100000);//阻塞时间长，此时发生中断状态更改，volatile无效
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        WrongWayVolatile r = new WrongWayVolatile();
        Thread thread = new Thread(r);
        thread.start();
        Thread.sleep(5000);
        r.canceled = true;
        System.out.println("发起中断");
    }
}
```

# try/catch，loop为何会影响中断
java线程中断就是基于try/catch的。interrupt只会更改线程的状态。具体的中断业务代码需要自己写
try/catch在loop中，每次都是单独的一次运行，但是将loop放在try/catch中就不一样了

# 在loop中throw InterruptedException会不会中断循环？
