[TOC]

活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。




死锁是最常见的活跃性问题，不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺利执行，统称为活跃性问题
活锁
饥饿

工程中的活锁实例：消息队列
如何解决活锁问题

死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉
活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉
（优化策略，等待时间不同）

在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源

什么是活锁
虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但是程序却得不得进展，因为线程始终重复做同样的事。

如果这里死锁，那么就是这里两个人始终一动不动，直到对方先抬头，他们之间不再说话了，只是等待

活锁与业务逻辑息息相关

如何解决活锁问题
原因：重试机制不变，消息队列始终重试，吃饭始终谦让
以太网的指数退避算法
加入随机因素

工程中的活锁实例：消息队列
策略：消息如果处理失败，就放在队列开头重试
由于依赖服务除了问题，处理该消息一直失败
没阻塞，但程序无法继续

如果处理失败的消息放到队列尾部就不会发生死锁，最好加上重试限制，如果过了限制（重试n次）我们就认为它短时间无法恢复了，这个时候我们把这个数据放到数据库中，触发处理机制

饥饿
当线程需要某些资源（例如CPU）,但是却始终得不得
线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环而不释放锁，或者某程序始终占用某文件的写锁。

饥饿可能会导致响应性差：
比如，我们的浏览器有一个线程负责处理前台响应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程把CPU资源都占用了，那么前台线程将无法得到很好地执行，这会导致用户的体验很差。

线程优先级
10个级别，默认5
程序设计不应依赖于优先级，不同的操作系统不一样
windows有7个优先级
linux会忽略优先级

优先级会被操作系统改变

# 常见面试问题
1. 写一个必然死锁例子
2. 生产中什么情况下会发生死锁？（最明显的情况，在一个方法中获取多个锁；在一个方法中获取一个锁，再去调用其他的方法，在其他的方法中又去调用了锁）
3. 发生死锁必须满足的条件（1互斥条件、2请求与保持条件、3不剥夺条件、4循环等待条件）
4. 如何定位死锁（jstack、ThreadMXBean）
5. 有哪些解决死锁的问题的策略？（1避免策略：哲学家就餐的换手方法、转账换序方案。2检查与恢复策略：一段时间检测是否有死锁，如歌有就剥夺某一个资源，来打破死锁。3鸵鸟策略）
6. 讲一讲经典的哲学家就餐问题（多种解决方案：1服务员检查（避免策略）2改变一个哲学家拿叉子的顺序（避免策略）3餐票（避免策略）4领导调节（检测与恢复策略））
7. 实际工程中如何避免死锁？（1设置超时时间。2多使用并发类而不是自己设计锁。3尽量降低锁的使用粒度：用不用的锁而不是一个锁。4如果能使用同步代码块，就不使用同步方法：自己指定锁对象。5给线程起个有意义的名字：debug和排查时事半功倍，框架和jdk都遵循这个最佳实践。6避免锁的嵌套：MustDeadLock类。7分配资源前先看能不能收回来：银行间算法。8尽量不要几个功能用同一把锁：专锁专用）
8. 什么是活跃性问题？活锁、饥饿和死锁有什么区别？
